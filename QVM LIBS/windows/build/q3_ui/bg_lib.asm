code
proc swapfunc 24 0
file "../../../code/game/bg_lib.c"
line 76
;1://
;2://
;3:// bg_lib,c -- standard C library replacement routines used by code
;4:// compiled for the virtual machine
;5:
;6:#ifdef Q3_VM
;7:
;8:#include "../qcommon/q_shared.h"
;9:
;10:/*-
;11: * Copyright (c) 1992, 1993
;12: *	The Regents of the University of California.  All rights reserved.
;13: *
;14: * Redistribution and use in source and binary forms, with or without
;15: * modification, are permitted provided that the following conditions
;16: * are met:
;17: * 1. Redistributions of source code must retain the above copyright
;18: *    notice, this list of conditions and the following disclaimer.
;19: * 2. Redistributions in binary form must reproduce the above copyright
;20: *    notice, this list of conditions and the following disclaimer in the
;21: *    documentation and/or other materials provided with the distribution.
;22: * 3. Neither the name of the University nor the names of its contributors
;23: *    may be used to endorse or promote products derived from this software
;24: *    without specific prior written permission.
;25: *
;26: * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
;27: * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;28: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;29: * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
;30: * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;31: * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
;32: * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
;33: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
;34: * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
;35: * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
;36: * SUCH DAMAGE.
;37: */
;38:
;39:#include "bg_lib.h"
;40:
;41:#if defined(LIBC_SCCS) && !defined(lint)
;42:#if 0
;43:static char sccsid[] = "@(#)qsort.c	8.1 (Berkeley) 6/4/93";
;44:#endif
;45:static const char rcsid[] =
;46:#endif /* LIBC_SCCS and not lint */
;47:
;48:static char* med3(char *, char *, char *, cmp_t *);
;49:static void	 swapfunc(char *, char *, int, int);
;50:
;51:#ifndef min
;52:#define min(a, b)	((a) < (b) ? (a) : (b))
;53:#endif
;54:
;55:/*
;56: * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
;57: */
;58:#define swapcode(TYPE, parmi, parmj, n) { 		\
;59:	long i = (n) / sizeof (TYPE); 			\
;60:	register TYPE *pi = (TYPE *) (parmi); 		\
;61:	register TYPE *pj = (TYPE *) (parmj); 		\
;62:	do { 						\
;63:		register TYPE	t = *pi;		\
;64:		*pi++ = *pj;				\
;65:		*pj++ = t;				\
;66:        } while (--i > 0);				\
;67:}
;68:
;69:#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
;70:	es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;
;71:
;72:static void
;73:swapfunc(a, b, n, swaptype)
;74:	char *a, *b;
;75:	int n, swaptype;
;76:{
line 77
;77:	if(swaptype <= 1)
ADDRFP4 12
INDIRI4
CNSTI4 1
GTI4 $24
line 78
;78:		swapcode(long, a, b, n)
ADDRLP4 8
ADDRFP4 8
INDIRI4
CVIU4 4
CNSTI4 2
RSHU4
CVUI4 4
ASGNI4
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
LABELV $26
ADDRLP4 12
ADDRLP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 16
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 20
INDIRP4
CNSTI4 4
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 12
INDIRI4
ASGNI4
LABELV $27
ADDRLP4 12
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 8
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
GTI4 $26
ADDRGP4 $25
JUMPV
LABELV $24
line 80
;79:	else
;80:		swapcode(char, a, b, n)
ADDRLP4 8
ADDRFP4 8
INDIRI4
CVIU4 4
CVUI4 4
ASGNI4
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
LABELV $29
ADDRLP4 12
ADDRLP4 0
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 16
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 16
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 16
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI1
ASGNI1
ADDRLP4 20
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
ADDRLP4 12
INDIRI1
ASGNI1
LABELV $30
ADDRLP4 12
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 8
ADDRLP4 12
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
GTI4 $29
LABELV $25
line 81
;81:}
LABELV $23
endproc swapfunc 24 0
proc med3 40 8
line 97
;82:
;83:#define swap(a, b)					\
;84:	if (swaptype == 0) {				\
;85:		long t = *(long *)(a);			\
;86:		*(long *)(a) = *(long *)(b);		\
;87:		*(long *)(b) = t;			\
;88:	} else						\
;89:		swapfunc(a, b, es, swaptype)
;90:
;91:#define vecswap(a, b, n) 	if ((n) > 0) swapfunc(a, b, n, swaptype)
;92:
;93:static char *
;94:med3(a, b, c, cmp)
;95:	char *a, *b, *c;
;96:	cmp_t *cmp;
;97:{
line 98
;98:	return cmp(a, b) < 0 ?
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRLP4 20
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
GEI4 $38
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 24
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
GEI4 $40
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $41
JUMPV
LABELV $40
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 28
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 0
GEI4 $42
ADDRLP4 8
ADDRFP4 8
INDIRP4
ASGNP4
ADDRGP4 $43
JUMPV
LABELV $42
ADDRLP4 8
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $43
ADDRLP4 4
ADDRLP4 8
INDIRP4
ASGNP4
LABELV $41
ADDRLP4 0
ADDRLP4 4
INDIRP4
ASGNP4
ADDRGP4 $39
JUMPV
LABELV $38
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 32
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 0
LEI4 $44
ADDRLP4 12
ADDRFP4 4
INDIRP4
ASGNP4
ADDRGP4 $45
JUMPV
LABELV $44
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 36
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 0
GEI4 $46
ADDRLP4 16
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $47
JUMPV
LABELV $46
ADDRLP4 16
ADDRFP4 8
INDIRP4
ASGNP4
LABELV $47
ADDRLP4 12
ADDRLP4 16
INDIRP4
ASGNP4
LABELV $45
ADDRLP4 0
ADDRLP4 12
INDIRP4
ASGNP4
LABELV $39
ADDRLP4 0
INDIRP4
RETP4
LABELV $32
endproc med3 40 8
export qsort
proc qsort 104 16
line 108
;99:	       (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))
;100:              :(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));
;101:}
;102:
;103:void
;104:qsort(a, n, es, cmp)
;105:	void *a;
;106:	size_t n, es;
;107:	cmp_t *cmp;
;108:{
LABELV $49
line 112
;109:	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
;110:	int d, r, swaptype, swap_cnt;
;111:
;112:loop:	SWAPINIT(a, es);
ADDRLP4 52
CNSTU4 3
ASGNU4
ADDRLP4 56
CNSTU4 0
ASGNU4
ADDRFP4 0
INDIRP4
CVPU4 4
CVUI4 4
CVIU4 4
ADDRLP4 52
INDIRU4
BANDU4
ADDRLP4 56
INDIRU4
NEU4 $54
ADDRFP4 8
INDIRI4
CVIU4 4
ADDRLP4 52
INDIRU4
BANDU4
ADDRLP4 56
INDIRU4
EQU4 $52
LABELV $54
ADDRLP4 44
CNSTI4 2
ASGNI4
ADDRGP4 $53
JUMPV
LABELV $52
ADDRFP4 8
INDIRI4
CVIU4 4
CNSTU4 4
NEU4 $55
ADDRLP4 48
CNSTI4 0
ASGNI4
ADDRGP4 $56
JUMPV
LABELV $55
ADDRLP4 48
CNSTI4 1
ASGNI4
LABELV $56
ADDRLP4 44
ADDRLP4 48
INDIRI4
ASGNI4
LABELV $53
ADDRLP4 16
ADDRLP4 44
INDIRI4
ASGNI4
line 113
;113:	swap_cnt = 0;
ADDRLP4 28
CNSTI4 0
ASGNI4
line 114
;114:	if (n < 7) {
ADDRFP4 4
INDIRI4
CNSTI4 7
GEI4 $57
line 115
;115:		for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRGP4 $62
JUMPV
LABELV $59
line 116
;116:			for (pl = pm; pl > (char *)a && cmp(pl - es, pl) > 0;
ADDRLP4 0
ADDRLP4 32
INDIRP4
ASGNP4
ADDRGP4 $66
JUMPV
LABELV $63
line 118
;117:			     pl -= es)
;118:				swap(pl, pl - es);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $67
ADDRLP4 60
ADDRLP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ADDRLP4 60
INDIRI4
ASGNI4
ADDRGP4 $68
JUMPV
LABELV $67
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 64
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 64
INDIRI4
SUBP4
ARGP4
ADDRLP4 64
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $68
LABELV $64
line 117
ADDRLP4 0
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
LABELV $66
line 116
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
LEU4 $69
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 72
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 72
INDIRI4
CNSTI4 0
GTI4 $63
LABELV $69
LABELV $60
line 115
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRLP4 32
INDIRP4
ADDP4
ASGNP4
LABELV $62
ADDRLP4 32
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
CVPU4 4
LTU4 $59
line 119
;119:		return;
ADDRGP4 $48
JUMPV
LABELV $57
line 121
;120:	}
;121:	pm = (char *)a + (n / 2) * es;
ADDRLP4 32
ADDRFP4 4
INDIRI4
CNSTI4 2
DIVI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
line 122
;122:	if (n > 7) {
ADDRFP4 4
INDIRI4
CNSTI4 7
LEI4 $70
line 123
;123:		pl = a;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
line 124
;124:		pn = (char *)a + (n - 1) * es;
ADDRLP4 36
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
line 125
;125:		if (n > 40) {
ADDRFP4 4
INDIRI4
CNSTI4 40
LEI4 $72
line 126
;126:			d = (n / 8) * es;
ADDRLP4 40
ADDRFP4 4
INDIRI4
CNSTI4 8
DIVI4
ADDRFP4 8
INDIRI4
MULI4
ASGNI4
line 127
;127:			pl = med3(pl, pl + d, pl + 2 * d, cmp);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 64
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 64
INDIRI4
ADDRLP4 0
INDIRP4
ADDP4
ARGP4
ADDRLP4 64
INDIRI4
CNSTI4 1
LSHI4
ADDRLP4 0
INDIRP4
ADDP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 68
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 0
ADDRLP4 68
INDIRP4
ASGNP4
line 128
;128:			pm = med3(pm - d, pm, pm + d, cmp);
ADDRLP4 76
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 32
INDIRP4
ADDRLP4 76
INDIRI4
SUBP4
ARGP4
ADDRLP4 32
INDIRP4
ARGP4
ADDRLP4 76
INDIRI4
ADDRLP4 32
INDIRP4
ADDP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 80
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 32
ADDRLP4 80
INDIRP4
ASGNP4
line 129
;129:			pn = med3(pn - 2 * d, pn - d, pn, cmp);
ADDRLP4 88
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 36
INDIRP4
ADDRLP4 88
INDIRI4
CNSTI4 1
LSHI4
SUBP4
ARGP4
ADDRLP4 36
INDIRP4
ADDRLP4 88
INDIRI4
SUBP4
ARGP4
ADDRLP4 36
INDIRP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 92
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 36
ADDRLP4 92
INDIRP4
ASGNP4
line 130
;130:		}
LABELV $72
line 131
;131:		pm = med3(pl, pm, pn, cmp);
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 32
INDIRP4
ARGP4
ADDRLP4 36
INDIRP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 60
ADDRGP4 med3
CALLP4
ASGNP4
ADDRLP4 32
ADDRLP4 60
INDIRP4
ASGNP4
line 132
;132:	}
LABELV $70
line 133
;133:	swap(a, pm);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $74
ADDRLP4 60
ADDRFP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRFP4 0
INDIRP4
ADDRLP4 32
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 32
INDIRP4
ADDRLP4 60
INDIRI4
ASGNI4
ADDRGP4 $75
JUMPV
LABELV $74
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 32
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $75
line 134
;134:	pa = pb = (char *)a + es;
ADDRLP4 60
ADDRFP4 8
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 60
INDIRP4
ASGNP4
ADDRLP4 20
ADDRLP4 60
INDIRP4
ASGNP4
line 136
;135:
;136:	pc = pd = (char *)a + (n - 1) * es;
ADDRLP4 64
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRLP4 24
ADDRLP4 64
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 64
INDIRP4
ASGNP4
line 137
;137:	for (;;) {
ADDRGP4 $81
JUMPV
LABELV $80
line 138
;138:		while (pb <= pc && (r = cmp(pb, a)) <= 0) {
line 139
;139:			if (r == 0) {
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $83
line 140
;140:				swap_cnt = 1;
ADDRLP4 28
CNSTI4 1
ASGNI4
line 141
;141:				swap(pa, pb);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $85
ADDRLP4 68
ADDRLP4 20
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 20
INDIRP4
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRP4
ADDRLP4 68
INDIRI4
ASGNI4
ADDRGP4 $86
JUMPV
LABELV $85
ADDRLP4 20
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $86
line 142
;142:				pa += es;
ADDRLP4 20
ADDRFP4 8
INDIRI4
ADDRLP4 20
INDIRP4
ADDP4
ASGNP4
line 143
;143:			}
LABELV $83
line 144
;144:			pb += es;
ADDRLP4 4
ADDRFP4 8
INDIRI4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
line 145
;145:		}
LABELV $81
line 138
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
GTU4 $87
ADDRLP4 4
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 72
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 72
INDIRI4
ASGNI4
ADDRLP4 72
INDIRI4
CNSTI4 0
LEI4 $80
LABELV $87
ADDRGP4 $89
JUMPV
LABELV $88
line 146
;146:		while (pb <= pc && (r = cmp(pc, a)) >= 0) {
line 147
;147:			if (r == 0) {
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $91
line 148
;148:				swap_cnt = 1;
ADDRLP4 28
CNSTI4 1
ASGNI4
line 149
;149:				swap(pc, pd);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $93
ADDRLP4 76
ADDRLP4 8
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 8
INDIRP4
ADDRLP4 24
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 24
INDIRP4
ADDRLP4 76
INDIRI4
ASGNI4
ADDRGP4 $94
JUMPV
LABELV $93
ADDRLP4 8
INDIRP4
ARGP4
ADDRLP4 24
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $94
line 150
;150:				pd -= es;
ADDRLP4 24
ADDRLP4 24
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
line 151
;151:			}
LABELV $91
line 152
;152:			pc -= es;
ADDRLP4 8
ADDRLP4 8
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
line 153
;153:		}
LABELV $89
line 146
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
GTU4 $95
ADDRLP4 8
INDIRP4
ARGP4
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 80
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 80
INDIRI4
ASGNI4
ADDRLP4 80
INDIRI4
CNSTI4 0
GEI4 $88
LABELV $95
line 154
;154:		if (pb > pc)
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
LEU4 $96
line 155
;155:			break;
ADDRGP4 $78
JUMPV
LABELV $96
line 156
;156:		swap(pb, pc);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $98
ADDRLP4 84
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 8
INDIRP4
ADDRLP4 84
INDIRI4
ASGNI4
ADDRGP4 $99
JUMPV
LABELV $98
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 8
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $99
line 157
;157:		swap_cnt = 1;
ADDRLP4 28
CNSTI4 1
ASGNI4
line 158
;158:		pb += es;
ADDRLP4 4
ADDRFP4 8
INDIRI4
ADDRLP4 4
INDIRP4
ADDP4
ASGNP4
line 159
;159:		pc -= es;
ADDRLP4 8
ADDRLP4 8
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
line 160
;160:	}
line 137
ADDRGP4 $81
JUMPV
LABELV $78
line 161
;161:	if (swap_cnt == 0) {  /* Switch to insertion sort */
ADDRLP4 28
INDIRI4
CNSTI4 0
NEI4 $100
line 162
;162:		for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
ADDRGP4 $105
JUMPV
LABELV $102
line 163
;163:			for (pl = pm; pl > (char *)a && cmp(pl - es, pl) > 0;
ADDRLP4 0
ADDRLP4 32
INDIRP4
ASGNP4
ADDRGP4 $109
JUMPV
LABELV $106
line 165
;164:			     pl -= es)
;165:				swap(pl, pl - es);
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $110
ADDRLP4 68
ADDRLP4 0
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ADDRLP4 68
INDIRI4
ASGNI4
ADDRGP4 $111
JUMPV
LABELV $110
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 72
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 0
INDIRP4
ADDRLP4 72
INDIRI4
SUBP4
ARGP4
ADDRLP4 72
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $111
LABELV $107
line 164
ADDRLP4 0
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ASGNP4
LABELV $109
line 163
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
LEU4 $112
ADDRLP4 0
INDIRP4
ADDRFP4 8
INDIRI4
SUBP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 80
ADDRFP4 12
INDIRP4
CALLI4
ASGNI4
ADDRLP4 80
INDIRI4
CNSTI4 0
GTI4 $106
LABELV $112
LABELV $103
line 162
ADDRLP4 32
ADDRFP4 8
INDIRI4
ADDRLP4 32
INDIRP4
ADDP4
ASGNP4
LABELV $105
ADDRLP4 32
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
CVPU4 4
LTU4 $102
line 166
;166:		return;
ADDRGP4 $48
JUMPV
LABELV $100
line 169
;167:	}
;168:
;169:	pn = (char *)a + n * es;
ADDRLP4 36
ADDRFP4 4
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRFP4 0
INDIRP4
ADDP4
ASGNP4
line 170
;170:	r = min(pa - (char *)a, pb - pa);
ADDRLP4 72
ADDRLP4 20
INDIRP4
CVPU4 4
ASGNU4
ADDRLP4 72
INDIRU4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 72
INDIRU4
SUBU4
CVUI4 4
GEI4 $114
ADDRLP4 68
ADDRLP4 20
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRGP4 $115
JUMPV
LABELV $114
ADDRLP4 68
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 20
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
LABELV $115
ADDRLP4 12
ADDRLP4 68
INDIRI4
ASGNI4
line 171
;171:	vecswap(a, pb - r, r);
ADDRLP4 12
INDIRI4
CNSTI4 0
LEI4 $116
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
SUBP4
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $116
line 172
;172:	r = min(pd - pc, pn - pd - es);
ADDRLP4 84
ADDRLP4 24
INDIRP4
CVPU4 4
ASGNU4
ADDRLP4 84
INDIRU4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ADDRLP4 36
INDIRP4
CVPU4 4
ADDRLP4 84
INDIRU4
SUBU4
CVUI4 4
ADDRFP4 8
INDIRI4
SUBI4
GEI4 $119
ADDRLP4 80
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRGP4 $120
JUMPV
LABELV $119
ADDRLP4 80
ADDRLP4 36
INDIRP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ADDRFP4 8
INDIRI4
SUBI4
ASGNI4
LABELV $120
ADDRLP4 12
ADDRLP4 80
INDIRI4
ASGNI4
line 173
;173:	vecswap(pb, pn - r, r);
ADDRLP4 12
INDIRI4
CNSTI4 0
LEI4 $121
ADDRLP4 4
INDIRP4
ARGP4
ADDRLP4 36
INDIRP4
ADDRLP4 12
INDIRI4
SUBP4
ARGP4
ADDRLP4 12
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRGP4 swapfunc
CALLV
pop
LABELV $121
line 174
;174:	if ((r = pb - pa) > es)
ADDRLP4 92
ADDRLP4 4
INDIRP4
CVPU4 4
ADDRLP4 20
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRLP4 12
ADDRLP4 92
INDIRI4
ASGNI4
ADDRLP4 92
INDIRI4
ADDRFP4 8
INDIRI4
LEI4 $123
line 175
;175:		qsort(a, r / es, es, cmp);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 96
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 12
INDIRI4
ADDRLP4 96
INDIRI4
DIVI4
ARGI4
ADDRLP4 96
INDIRI4
ARGI4
ADDRFP4 12
INDIRP4
ARGP4
ADDRGP4 qsort
CALLV
pop
LABELV $123
line 176
;176:	if ((r = pd - pc) > es) {
ADDRLP4 100
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRLP4 8
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
ASGNI4
ADDRLP4 12
ADDRLP4 100
INDIRI4
ASGNI4
ADDRLP4 100
INDIRI4
ADDRFP4 8
INDIRI4
LEI4 $125
line 178
;177:		/* Iterate rather than recurse to save stack space */
;178:		a = pn - r;
ADDRFP4 0
ADDRLP4 36
INDIRP4
ADDRLP4 12
INDIRI4
SUBP4
ASGNP4
line 179
;179:		n = r / es;
ADDRFP4 4
ADDRLP4 12
INDIRI4
ADDRFP4 8
INDIRI4
DIVI4
ASGNI4
line 180
;180:		goto loop;
ADDRGP4 $49
JUMPV
LABELV $125
line 183
;181:	}
;182:/*		qsort(pn - r, r / es, es, cmp);*/
;183:}
LABELV $48
endproc qsort 104 16
export strlen
proc strlen 4 0
line 187
;184:
;185://==================================================================================
;186:
;187:size_t strlen( const char *string ) {
line 190
;188:	const char	*s;
;189:
;190:	s = string;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $129
JUMPV
LABELV $128
line 191
;191:	while ( *s ) {
line 192
;192:		s++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 193
;193:	}
LABELV $129
line 191
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $128
line 194
;194:	return s - string;
ADDRLP4 0
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
SUBU4
CVUI4 4
RETI4
LABELV $127
endproc strlen 4 0
export strcat
proc strcat 16 0
line 198
;195:}
;196:
;197:
;198:char *strcat( char *strDestination, const char *strSource ) {
line 201
;199:	char	*s;
;200:
;201:	s = strDestination;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $133
JUMPV
LABELV $132
line 202
;202:	while ( *s ) {
line 203
;203:		s++;
ADDRLP4 0
ADDRLP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 204
;204:	}
LABELV $133
line 202
ADDRLP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $132
ADDRGP4 $136
JUMPV
LABELV $135
line 205
;205:	while ( *strSource ) {
line 206
;206:		*s++ = *strSource++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 207
;207:	}
LABELV $136
line 205
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $135
line 208
;208:	*s = 0;
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 209
;209:	return strDestination;
ADDRFP4 0
INDIRP4
RETP4
LABELV $131
endproc strcat 16 0
export strcpy
proc strcpy 16 0
line 212
;210:}
;211:
;212:char *strcpy( char *strDestination, const char *strSource ) {
line 215
;213:	char *s;
;214:
;215:	s = strDestination;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
ADDRGP4 $140
JUMPV
LABELV $139
line 216
;216:	while ( *strSource ) {
line 217
;217:		*s++ = *strSource++;
ADDRLP4 4
ADDRLP4 0
INDIRP4
ASGNP4
ADDRLP4 12
CNSTI4 1
ASGNI4
ADDRLP4 0
ADDRLP4 4
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 8
ADDRFP4 4
INDIRP4
ASGNP4
ADDRFP4 4
ADDRLP4 8
INDIRP4
ADDRLP4 12
INDIRI4
ADDP4
ASGNP4
ADDRLP4 4
INDIRP4
ADDRLP4 8
INDIRP4
INDIRI1
ASGNI1
line 218
;218:	}
LABELV $140
line 216
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $139
line 219
;219:	*s = 0;
ADDRLP4 0
INDIRP4
CNSTI1 0
ASGNI1
line 220
;220:	return strDestination;
ADDRFP4 0
INDIRP4
RETP4
LABELV $138
endproc strcpy 16 0
export strcmp
proc strcmp 12 0
line 224
;221:}
;222:
;223:
;224:int strcmp( const char *string1, const char *string2 ) {
ADDRGP4 $144
JUMPV
LABELV $143
line 225
;225:	while ( *string1 == *string2 && *string1 && *string2 ) {
line 226
;226:		string1++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 227
;227:		string2++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 228
;228:	}
LABELV $144
line 225
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 4
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 4
INDIRI4
NEI4 $147
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 8
INDIRI4
EQI4 $147
ADDRLP4 4
INDIRI4
ADDRLP4 8
INDIRI4
NEI4 $143
LABELV $147
line 229
;229:	return *string1 - *string2;
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
SUBI4
RETI4
LABELV $142
endproc strcmp 12 0
export strchr
proc strchr 0 0
line 233
;230:}
;231:
;232:
;233:char *strchr( const char *string, int c ) {
ADDRGP4 $150
JUMPV
LABELV $149
line 234
;234:	while ( *string ) {
line 235
;235:		if ( *string == c ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRI4
NEI4 $152
line 236
;236:			return ( char * )string;
ADDRFP4 0
INDIRP4
RETP4
ADDRGP4 $148
JUMPV
LABELV $152
line 238
;237:		}
;238:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 239
;239:	}
LABELV $150
line 234
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $149
line 240
;240:	if(c)
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $154
line 241
;241:                return NULL;
CNSTP4 0
RETP4
ADDRGP4 $148
JUMPV
LABELV $154
line 243
;242:        else
;243:                return (char*) string;
ADDRFP4 0
INDIRP4
RETP4
LABELV $148
endproc strchr 0 0
export strrchr
proc strrchr 4 0
line 247
;244:}
;245:
;246:char *strrchr(const char *string, int c)
;247:{
line 248
;248:	const char *found = NULL;
ADDRLP4 0
CNSTP4 0
ASGNP4
ADDRGP4 $158
JUMPV
LABELV $157
line 251
;249:	
;250:	while(*string)
;251:	{
line 252
;252:		if(*string == c)
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ADDRFP4 4
INDIRI4
NEI4 $160
line 253
;253:			found = string;
ADDRLP4 0
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $160
line 255
;254:
;255:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 256
;256:	}
LABELV $158
line 250
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $157
line 258
;257:	
;258:	if(c)
ADDRFP4 4
INDIRI4
CNSTI4 0
EQI4 $162
line 259
;259:		return (char *) found;
ADDRLP4 0
INDIRP4
RETP4
ADDRGP4 $156
JUMPV
LABELV $162
line 261
;260:	else
;261:		return (char *) string;
ADDRFP4 0
INDIRP4
RETP4
LABELV $156
endproc strrchr 4 0
export strstr
proc strstr 8 0
line 264
;262:}
;263:
;264:char *strstr( const char *string, const char *strCharSet ) {
ADDRGP4 $166
JUMPV
LABELV $165
line 265
;265:	while ( *string ) {
line 268
;266:		int		i;
;267:
;268:		for ( i = 0 ; strCharSet[i] ; i++ ) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $171
JUMPV
LABELV $168
line 269
;269:			if ( string[i] != strCharSet[i] ) {
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
INDIRI1
CVII4 1
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
EQI4 $172
line 270
;270:				break;
ADDRGP4 $170
JUMPV
LABELV $172
line 272
;271:			}
;272:		}
LABELV $169
line 268
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $171
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $168
LABELV $170
line 273
;273:		if ( !strCharSet[i] ) {
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $174
line 274
;274:			return (char *)string;
ADDRFP4 0
INDIRP4
RETP4
ADDRGP4 $164
JUMPV
LABELV $174
line 276
;275:		}
;276:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 277
;277:	}
LABELV $166
line 265
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $165
line 278
;278:	return (char *)0;
CNSTP4 0
RETP4
LABELV $164
endproc strstr 8 0
export tolower
proc tolower 4 0
line 281
;279:}
;280:
;281:int tolower( int c ) {
line 282
;282:	if ( c >= 'A' && c <= 'Z' ) {
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 65
LTI4 $177
ADDRLP4 0
INDIRI4
CNSTI4 90
GTI4 $177
line 283
;283:		c += 'a' - 'A';
ADDRFP4 0
ADDRFP4 0
INDIRI4
CNSTI4 32
ADDI4
ASGNI4
line 284
;284:	}
LABELV $177
line 285
;285:	return c;
ADDRFP4 0
INDIRI4
RETI4
LABELV $176
endproc tolower 4 0
export toupper
proc toupper 4 0
line 289
;286:}
;287:
;288:
;289:int toupper( int c ) {
line 290
;290:	if ( c >= 'a' && c <= 'z' ) {
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
ADDRLP4 0
INDIRI4
CNSTI4 97
LTI4 $180
ADDRLP4 0
INDIRI4
CNSTI4 122
GTI4 $180
line 291
;291:		c += 'A' - 'a';
ADDRFP4 0
ADDRFP4 0
INDIRI4
CNSTI4 -32
ADDI4
ASGNI4
line 292
;292:	}
LABELV $180
line 293
;293:	return c;
ADDRFP4 0
INDIRI4
RETI4
LABELV $179
endproc toupper 4 0
export memmove
proc memmove 8 0
line 296
;294:}
;295:
;296:void *memmove( void *dest, const void *src, size_t count ) {
line 299
;297:	int		i;
;298:
;299:	if ( dest > src ) {
ADDRFP4 0
INDIRP4
CVPU4 4
ADDRFP4 4
INDIRP4
CVPU4 4
LEU4 $183
line 300
;300:		for ( i = count-1 ; i >= 0 ; i-- ) {
ADDRLP4 0
ADDRFP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRGP4 $188
JUMPV
LABELV $185
line 301
;301:			((char *)dest)[i] = ((char *)src)[i];
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 302
;302:		}
LABELV $186
line 300
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $188
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $185
line 303
;303:	} else {
ADDRGP4 $184
JUMPV
LABELV $183
line 304
;304:		for ( i = 0 ; i < count ; i++ ) {
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $192
JUMPV
LABELV $189
line 305
;305:			((char *)dest)[i] = ((char *)src)[i];
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRLP4 0
INDIRI4
ADDRFP4 4
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 306
;306:		}
LABELV $190
line 304
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $192
ADDRLP4 0
INDIRI4
ADDRFP4 8
INDIRI4
LTI4 $189
line 307
;307:	}
LABELV $184
line 308
;308:	return dest;
ADDRFP4 0
INDIRP4
RETP4
LABELV $182
endproc memmove 8 0
export tan
proc tan 8 4
line 763
;309:}
;310:
;311:
;312:#if 0
;313:
;314:double floor( double x ) {
;315:	return (int)(x + 0x40000000) - 0x40000000;
;316:}
;317:
;318:void *memset( void *dest, int c, size_t count ) {
;319:	while ( count-- ) {
;320:		((char *)dest)[count] = c;
;321:	}
;322:	return dest;
;323:}
;324:
;325:void *memcpy( void *dest, const void *src, size_t count ) {
;326:	while ( count-- ) {
;327:		((char *)dest)[count] = ((char *)src)[count];
;328:	}
;329:	return dest;
;330:}
;331:
;332:char *strncpy( char *strDest, const char *strSource, size_t count ) {
;333:	char	*s;
;334:
;335:	s = strDest;
;336:	while ( *strSource && count ) {
;337:		*s++ = *strSource++;
;338:		count--;
;339:	}
;340:	while ( count-- ) {
;341:		*s++ = 0;
;342:	}
;343:	return strDest;
;344:}
;345:
;346:double sqrt( double x ) {
;347:	float	y;
;348:	float	delta;
;349:	float	maxError;
;350:
;351:	if ( x <= 0 ) {
;352:		return 0;
;353:	}
;354:
;355:	// initial guess
;356:	y = x / 2;
;357:
;358:	// refine
;359:	maxError = x * 0.001;
;360:
;361:	do {
;362:		delta = ( y * y ) - x;
;363:		y -= delta / ( 2 * y );
;364:	} while ( delta > maxError || delta < -maxError );
;365:
;366:	return y;
;367:}
;368:
;369:
;370:float sintable[1024] = {
;371:0.000000,0.001534,0.003068,0.004602,0.006136,0.007670,0.009204,0.010738,
;372:0.012272,0.013805,0.015339,0.016873,0.018407,0.019940,0.021474,0.023008,
;373:0.024541,0.026075,0.027608,0.029142,0.030675,0.032208,0.033741,0.035274,
;374:0.036807,0.038340,0.039873,0.041406,0.042938,0.044471,0.046003,0.047535,
;375:0.049068,0.050600,0.052132,0.053664,0.055195,0.056727,0.058258,0.059790,
;376:0.061321,0.062852,0.064383,0.065913,0.067444,0.068974,0.070505,0.072035,
;377:0.073565,0.075094,0.076624,0.078153,0.079682,0.081211,0.082740,0.084269,
;378:0.085797,0.087326,0.088854,0.090381,0.091909,0.093436,0.094963,0.096490,
;379:0.098017,0.099544,0.101070,0.102596,0.104122,0.105647,0.107172,0.108697,
;380:0.110222,0.111747,0.113271,0.114795,0.116319,0.117842,0.119365,0.120888,
;381:0.122411,0.123933,0.125455,0.126977,0.128498,0.130019,0.131540,0.133061,
;382:0.134581,0.136101,0.137620,0.139139,0.140658,0.142177,0.143695,0.145213,
;383:0.146730,0.148248,0.149765,0.151281,0.152797,0.154313,0.155828,0.157343,
;384:0.158858,0.160372,0.161886,0.163400,0.164913,0.166426,0.167938,0.169450,
;385:0.170962,0.172473,0.173984,0.175494,0.177004,0.178514,0.180023,0.181532,
;386:0.183040,0.184548,0.186055,0.187562,0.189069,0.190575,0.192080,0.193586,
;387:0.195090,0.196595,0.198098,0.199602,0.201105,0.202607,0.204109,0.205610,
;388:0.207111,0.208612,0.210112,0.211611,0.213110,0.214609,0.216107,0.217604,
;389:0.219101,0.220598,0.222094,0.223589,0.225084,0.226578,0.228072,0.229565,
;390:0.231058,0.232550,0.234042,0.235533,0.237024,0.238514,0.240003,0.241492,
;391:0.242980,0.244468,0.245955,0.247442,0.248928,0.250413,0.251898,0.253382,
;392:0.254866,0.256349,0.257831,0.259313,0.260794,0.262275,0.263755,0.265234,
;393:0.266713,0.268191,0.269668,0.271145,0.272621,0.274097,0.275572,0.277046,
;394:0.278520,0.279993,0.281465,0.282937,0.284408,0.285878,0.287347,0.288816,
;395:0.290285,0.291752,0.293219,0.294685,0.296151,0.297616,0.299080,0.300543,
;396:0.302006,0.303468,0.304929,0.306390,0.307850,0.309309,0.310767,0.312225,
;397:0.313682,0.315138,0.316593,0.318048,0.319502,0.320955,0.322408,0.323859,
;398:0.325310,0.326760,0.328210,0.329658,0.331106,0.332553,0.334000,0.335445,
;399:0.336890,0.338334,0.339777,0.341219,0.342661,0.344101,0.345541,0.346980,
;400:0.348419,0.349856,0.351293,0.352729,0.354164,0.355598,0.357031,0.358463,
;401:0.359895,0.361326,0.362756,0.364185,0.365613,0.367040,0.368467,0.369892,
;402:0.371317,0.372741,0.374164,0.375586,0.377007,0.378428,0.379847,0.381266,
;403:0.382683,0.384100,0.385516,0.386931,0.388345,0.389758,0.391170,0.392582,
;404:0.393992,0.395401,0.396810,0.398218,0.399624,0.401030,0.402435,0.403838,
;405:0.405241,0.406643,0.408044,0.409444,0.410843,0.412241,0.413638,0.415034,
;406:0.416430,0.417824,0.419217,0.420609,0.422000,0.423390,0.424780,0.426168,
;407:0.427555,0.428941,0.430326,0.431711,0.433094,0.434476,0.435857,0.437237,
;408:0.438616,0.439994,0.441371,0.442747,0.444122,0.445496,0.446869,0.448241,
;409:0.449611,0.450981,0.452350,0.453717,0.455084,0.456449,0.457813,0.459177,
;410:0.460539,0.461900,0.463260,0.464619,0.465976,0.467333,0.468689,0.470043,
;411:0.471397,0.472749,0.474100,0.475450,0.476799,0.478147,0.479494,0.480839,
;412:0.482184,0.483527,0.484869,0.486210,0.487550,0.488889,0.490226,0.491563,
;413:0.492898,0.494232,0.495565,0.496897,0.498228,0.499557,0.500885,0.502212,
;414:0.503538,0.504863,0.506187,0.507509,0.508830,0.510150,0.511469,0.512786,
;415:0.514103,0.515418,0.516732,0.518045,0.519356,0.520666,0.521975,0.523283,
;416:0.524590,0.525895,0.527199,0.528502,0.529804,0.531104,0.532403,0.533701,
;417:0.534998,0.536293,0.537587,0.538880,0.540171,0.541462,0.542751,0.544039,
;418:0.545325,0.546610,0.547894,0.549177,0.550458,0.551738,0.553017,0.554294,
;419:0.555570,0.556845,0.558119,0.559391,0.560662,0.561931,0.563199,0.564466,
;420:0.565732,0.566996,0.568259,0.569521,0.570781,0.572040,0.573297,0.574553,
;421:0.575808,0.577062,0.578314,0.579565,0.580814,0.582062,0.583309,0.584554,
;422:0.585798,0.587040,0.588282,0.589521,0.590760,0.591997,0.593232,0.594466,
;423:0.595699,0.596931,0.598161,0.599389,0.600616,0.601842,0.603067,0.604290,
;424:0.605511,0.606731,0.607950,0.609167,0.610383,0.611597,0.612810,0.614022,
;425:0.615232,0.616440,0.617647,0.618853,0.620057,0.621260,0.622461,0.623661,
;426:0.624859,0.626056,0.627252,0.628446,0.629638,0.630829,0.632019,0.633207,
;427:0.634393,0.635578,0.636762,0.637944,0.639124,0.640303,0.641481,0.642657,
;428:0.643832,0.645005,0.646176,0.647346,0.648514,0.649681,0.650847,0.652011,
;429:0.653173,0.654334,0.655493,0.656651,0.657807,0.658961,0.660114,0.661266,
;430:0.662416,0.663564,0.664711,0.665856,0.667000,0.668142,0.669283,0.670422,
;431:0.671559,0.672695,0.673829,0.674962,0.676093,0.677222,0.678350,0.679476,
;432:0.680601,0.681724,0.682846,0.683965,0.685084,0.686200,0.687315,0.688429,
;433:0.689541,0.690651,0.691759,0.692866,0.693971,0.695075,0.696177,0.697278,
;434:0.698376,0.699473,0.700569,0.701663,0.702755,0.703845,0.704934,0.706021,
;435:0.707107,0.708191,0.709273,0.710353,0.711432,0.712509,0.713585,0.714659,
;436:0.715731,0.716801,0.717870,0.718937,0.720003,0.721066,0.722128,0.723188,
;437:0.724247,0.725304,0.726359,0.727413,0.728464,0.729514,0.730563,0.731609,
;438:0.732654,0.733697,0.734739,0.735779,0.736817,0.737853,0.738887,0.739920,
;439:0.740951,0.741980,0.743008,0.744034,0.745058,0.746080,0.747101,0.748119,
;440:0.749136,0.750152,0.751165,0.752177,0.753187,0.754195,0.755201,0.756206,
;441:0.757209,0.758210,0.759209,0.760207,0.761202,0.762196,0.763188,0.764179,
;442:0.765167,0.766154,0.767139,0.768122,0.769103,0.770083,0.771061,0.772036,
;443:0.773010,0.773983,0.774953,0.775922,0.776888,0.777853,0.778817,0.779778,
;444:0.780737,0.781695,0.782651,0.783605,0.784557,0.785507,0.786455,0.787402,
;445:0.788346,0.789289,0.790230,0.791169,0.792107,0.793042,0.793975,0.794907,
;446:0.795837,0.796765,0.797691,0.798615,0.799537,0.800458,0.801376,0.802293,
;447:0.803208,0.804120,0.805031,0.805940,0.806848,0.807753,0.808656,0.809558,
;448:0.810457,0.811355,0.812251,0.813144,0.814036,0.814926,0.815814,0.816701,
;449:0.817585,0.818467,0.819348,0.820226,0.821103,0.821977,0.822850,0.823721,
;450:0.824589,0.825456,0.826321,0.827184,0.828045,0.828904,0.829761,0.830616,
;451:0.831470,0.832321,0.833170,0.834018,0.834863,0.835706,0.836548,0.837387,
;452:0.838225,0.839060,0.839894,0.840725,0.841555,0.842383,0.843208,0.844032,
;453:0.844854,0.845673,0.846491,0.847307,0.848120,0.848932,0.849742,0.850549,
;454:0.851355,0.852159,0.852961,0.853760,0.854558,0.855354,0.856147,0.856939,
;455:0.857729,0.858516,0.859302,0.860085,0.860867,0.861646,0.862424,0.863199,
;456:0.863973,0.864744,0.865514,0.866281,0.867046,0.867809,0.868571,0.869330,
;457:0.870087,0.870842,0.871595,0.872346,0.873095,0.873842,0.874587,0.875329,
;458:0.876070,0.876809,0.877545,0.878280,0.879012,0.879743,0.880471,0.881197,
;459:0.881921,0.882643,0.883363,0.884081,0.884797,0.885511,0.886223,0.886932,
;460:0.887640,0.888345,0.889048,0.889750,0.890449,0.891146,0.891841,0.892534,
;461:0.893224,0.893913,0.894599,0.895284,0.895966,0.896646,0.897325,0.898001,
;462:0.898674,0.899346,0.900016,0.900683,0.901349,0.902012,0.902673,0.903332,
;463:0.903989,0.904644,0.905297,0.905947,0.906596,0.907242,0.907886,0.908528,
;464:0.909168,0.909806,0.910441,0.911075,0.911706,0.912335,0.912962,0.913587,
;465:0.914210,0.914830,0.915449,0.916065,0.916679,0.917291,0.917901,0.918508,
;466:0.919114,0.919717,0.920318,0.920917,0.921514,0.922109,0.922701,0.923291,
;467:0.923880,0.924465,0.925049,0.925631,0.926210,0.926787,0.927363,0.927935,
;468:0.928506,0.929075,0.929641,0.930205,0.930767,0.931327,0.931884,0.932440,
;469:0.932993,0.933544,0.934093,0.934639,0.935184,0.935726,0.936266,0.936803,
;470:0.937339,0.937872,0.938404,0.938932,0.939459,0.939984,0.940506,0.941026,
;471:0.941544,0.942060,0.942573,0.943084,0.943593,0.944100,0.944605,0.945107,
;472:0.945607,0.946105,0.946601,0.947094,0.947586,0.948075,0.948561,0.949046,
;473:0.949528,0.950008,0.950486,0.950962,0.951435,0.951906,0.952375,0.952842,
;474:0.953306,0.953768,0.954228,0.954686,0.955141,0.955594,0.956045,0.956494,
;475:0.956940,0.957385,0.957826,0.958266,0.958703,0.959139,0.959572,0.960002,
;476:0.960431,0.960857,0.961280,0.961702,0.962121,0.962538,0.962953,0.963366,
;477:0.963776,0.964184,0.964590,0.964993,0.965394,0.965793,0.966190,0.966584,
;478:0.966976,0.967366,0.967754,0.968139,0.968522,0.968903,0.969281,0.969657,
;479:0.970031,0.970403,0.970772,0.971139,0.971504,0.971866,0.972226,0.972584,
;480:0.972940,0.973293,0.973644,0.973993,0.974339,0.974684,0.975025,0.975365,
;481:0.975702,0.976037,0.976370,0.976700,0.977028,0.977354,0.977677,0.977999,
;482:0.978317,0.978634,0.978948,0.979260,0.979570,0.979877,0.980182,0.980485,
;483:0.980785,0.981083,0.981379,0.981673,0.981964,0.982253,0.982539,0.982824,
;484:0.983105,0.983385,0.983662,0.983937,0.984210,0.984480,0.984749,0.985014,
;485:0.985278,0.985539,0.985798,0.986054,0.986308,0.986560,0.986809,0.987057,
;486:0.987301,0.987544,0.987784,0.988022,0.988258,0.988491,0.988722,0.988950,
;487:0.989177,0.989400,0.989622,0.989841,0.990058,0.990273,0.990485,0.990695,
;488:0.990903,0.991108,0.991311,0.991511,0.991710,0.991906,0.992099,0.992291,
;489:0.992480,0.992666,0.992850,0.993032,0.993212,0.993389,0.993564,0.993737,
;490:0.993907,0.994075,0.994240,0.994404,0.994565,0.994723,0.994879,0.995033,
;491:0.995185,0.995334,0.995481,0.995625,0.995767,0.995907,0.996045,0.996180,
;492:0.996313,0.996443,0.996571,0.996697,0.996820,0.996941,0.997060,0.997176,
;493:0.997290,0.997402,0.997511,0.997618,0.997723,0.997825,0.997925,0.998023,
;494:0.998118,0.998211,0.998302,0.998390,0.998476,0.998559,0.998640,0.998719,
;495:0.998795,0.998870,0.998941,0.999011,0.999078,0.999142,0.999205,0.999265,
;496:0.999322,0.999378,0.999431,0.999481,0.999529,0.999575,0.999619,0.999660,
;497:0.999699,0.999735,0.999769,0.999801,0.999831,0.999858,0.999882,0.999905,
;498:0.999925,0.999942,0.999958,0.999971,0.999981,0.999989,0.999995,0.999999
;499:};
;500:
;501:double sin( double x ) {
;502:	int	index;
;503:	int	quad;
;504:
;505:	index = 1024 * x / (M_PI * 0.5);
;506:	quad = ( index >> 10 ) & 3;
;507:	index &= 1023;
;508:	switch ( quad ) {
;509:	case 0:
;510:		return sintable[index];
;511:	case 1:
;512:		return sintable[1023-index];
;513:	case 2:
;514:		return -sintable[index];
;515:	case 3:
;516:		return -sintable[1023-index];
;517:	}
;518:	return 0;
;519:}
;520:
;521:
;522:double cos( double x ) {
;523:	int	index;
;524:	int	quad;
;525:
;526:	index = 1024 * x / (M_PI * 0.5);
;527:	quad = ( index >> 10 ) & 3;
;528:	index &= 1023;
;529:	switch ( quad ) {
;530:	case 3:
;531:		return sintable[index];
;532:	case 0:
;533:		return sintable[1023-index];
;534:	case 1:
;535:		return -sintable[index];
;536:	case 2:
;537:		return -sintable[1023-index];
;538:	}
;539:	return 0;
;540:}
;541:
;542:
;543:/*
;544:void create_acostable( void ) {
;545:	int i;
;546:	FILE *fp;
;547:	float a;
;548:
;549:	fp = fopen("c:\\acostable.txt", "w");
;550:	fprintf(fp, "float acostable[] = {");
;551:	for (i = 0; i < 1024; i++) {
;552:		if (!(i & 7))
;553:			fprintf(fp, "\n");
;554:		a = acos( (float) -1 + i / 512 );
;555:		fprintf(fp, "%1.8f,", a);
;556:	}
;557:	fprintf(fp, "\n}\n");
;558:	fclose(fp);
;559:}
;560:*/
;561:
;562:float acostable[] = {
;563:3.14159265,3.07908248,3.05317551,3.03328655,3.01651113,3.00172442,2.98834964,2.97604422,
;564:2.96458497,2.95381690,2.94362719,2.93393068,2.92466119,2.91576615,2.90720289,2.89893629,
;565:2.89093699,2.88318015,2.87564455,2.86831188,2.86116621,2.85419358,2.84738169,2.84071962,
;566:2.83419760,2.82780691,2.82153967,2.81538876,2.80934770,2.80341062,2.79757211,2.79182724,
;567:2.78617145,2.78060056,2.77511069,2.76969824,2.76435988,2.75909250,2.75389319,2.74875926,
;568:2.74368816,2.73867752,2.73372510,2.72882880,2.72398665,2.71919677,2.71445741,2.70976688,
;569:2.70512362,2.70052613,2.69597298,2.69146283,2.68699438,2.68256642,2.67817778,2.67382735,
;570:2.66951407,2.66523692,2.66099493,2.65678719,2.65261279,2.64847088,2.64436066,2.64028133,
;571:2.63623214,2.63221238,2.62822133,2.62425835,2.62032277,2.61641398,2.61253138,2.60867440,
;572:2.60484248,2.60103507,2.59725167,2.59349176,2.58975488,2.58604053,2.58234828,2.57867769,
;573:2.57502832,2.57139977,2.56779164,2.56420354,2.56063509,2.55708594,2.55355572,2.55004409,
;574:2.54655073,2.54307530,2.53961750,2.53617701,2.53275354,2.52934680,2.52595650,2.52258238,
;575:2.51922417,2.51588159,2.51255441,2.50924238,2.50594525,2.50266278,2.49939476,2.49614096,
;576:2.49290115,2.48967513,2.48646269,2.48326362,2.48007773,2.47690482,2.47374472,2.47059722,
;577:2.46746215,2.46433933,2.46122860,2.45812977,2.45504269,2.45196720,2.44890314,2.44585034,
;578:2.44280867,2.43977797,2.43675809,2.43374890,2.43075025,2.42776201,2.42478404,2.42181622,
;579:2.41885841,2.41591048,2.41297232,2.41004380,2.40712480,2.40421521,2.40131491,2.39842379,
;580:2.39554173,2.39266863,2.38980439,2.38694889,2.38410204,2.38126374,2.37843388,2.37561237,
;581:2.37279910,2.36999400,2.36719697,2.36440790,2.36162673,2.35885335,2.35608768,2.35332964,
;582:2.35057914,2.34783610,2.34510044,2.34237208,2.33965094,2.33693695,2.33423003,2.33153010,
;583:2.32883709,2.32615093,2.32347155,2.32079888,2.31813284,2.31547337,2.31282041,2.31017388,
;584:2.30753373,2.30489988,2.30227228,2.29965086,2.29703556,2.29442632,2.29182309,2.28922580,
;585:2.28663439,2.28404881,2.28146900,2.27889490,2.27632647,2.27376364,2.27120637,2.26865460,
;586:2.26610827,2.26356735,2.26103177,2.25850149,2.25597646,2.25345663,2.25094195,2.24843238,
;587:2.24592786,2.24342836,2.24093382,2.23844420,2.23595946,2.23347956,2.23100444,2.22853408,
;588:2.22606842,2.22360742,2.22115104,2.21869925,2.21625199,2.21380924,2.21137096,2.20893709,
;589:2.20650761,2.20408248,2.20166166,2.19924511,2.19683280,2.19442469,2.19202074,2.18962092,
;590:2.18722520,2.18483354,2.18244590,2.18006225,2.17768257,2.17530680,2.17293493,2.17056692,
;591:2.16820274,2.16584236,2.16348574,2.16113285,2.15878367,2.15643816,2.15409630,2.15175805,
;592:2.14942338,2.14709226,2.14476468,2.14244059,2.14011997,2.13780279,2.13548903,2.13317865,
;593:2.13087163,2.12856795,2.12626757,2.12397047,2.12167662,2.11938600,2.11709859,2.11481435,
;594:2.11253326,2.11025530,2.10798044,2.10570867,2.10343994,2.10117424,2.09891156,2.09665185,
;595:2.09439510,2.09214129,2.08989040,2.08764239,2.08539725,2.08315496,2.08091550,2.07867884,
;596:2.07644495,2.07421383,2.07198545,2.06975978,2.06753681,2.06531651,2.06309887,2.06088387,
;597:2.05867147,2.05646168,2.05425445,2.05204979,2.04984765,2.04764804,2.04545092,2.04325628,
;598:2.04106409,2.03887435,2.03668703,2.03450211,2.03231957,2.03013941,2.02796159,2.02578610,
;599:2.02361292,2.02144204,2.01927344,2.01710710,2.01494300,2.01278113,2.01062146,2.00846399,
;600:2.00630870,2.00415556,2.00200457,1.99985570,1.99770895,1.99556429,1.99342171,1.99128119,
;601:1.98914271,1.98700627,1.98487185,1.98273942,1.98060898,1.97848051,1.97635399,1.97422942,
;602:1.97210676,1.96998602,1.96786718,1.96575021,1.96363511,1.96152187,1.95941046,1.95730088,
;603:1.95519310,1.95308712,1.95098292,1.94888050,1.94677982,1.94468089,1.94258368,1.94048818,
;604:1.93839439,1.93630228,1.93421185,1.93212308,1.93003595,1.92795046,1.92586659,1.92378433,
;605:1.92170367,1.91962459,1.91754708,1.91547113,1.91339673,1.91132385,1.90925250,1.90718266,
;606:1.90511432,1.90304746,1.90098208,1.89891815,1.89685568,1.89479464,1.89273503,1.89067683,
;607:1.88862003,1.88656463,1.88451060,1.88245794,1.88040664,1.87835668,1.87630806,1.87426076,
;608:1.87221477,1.87017008,1.86812668,1.86608457,1.86404371,1.86200412,1.85996577,1.85792866,
;609:1.85589277,1.85385809,1.85182462,1.84979234,1.84776125,1.84573132,1.84370256,1.84167495,
;610:1.83964848,1.83762314,1.83559892,1.83357582,1.83155381,1.82953289,1.82751305,1.82549429,
;611:1.82347658,1.82145993,1.81944431,1.81742973,1.81541617,1.81340362,1.81139207,1.80938151,
;612:1.80737194,1.80536334,1.80335570,1.80134902,1.79934328,1.79733848,1.79533460,1.79333164,
;613:1.79132959,1.78932843,1.78732817,1.78532878,1.78333027,1.78133261,1.77933581,1.77733985,
;614:1.77534473,1.77335043,1.77135695,1.76936428,1.76737240,1.76538132,1.76339101,1.76140148,
;615:1.75941271,1.75742470,1.75543743,1.75345090,1.75146510,1.74948002,1.74749565,1.74551198,
;616:1.74352900,1.74154672,1.73956511,1.73758417,1.73560389,1.73362426,1.73164527,1.72966692,
;617:1.72768920,1.72571209,1.72373560,1.72175971,1.71978441,1.71780969,1.71583556,1.71386199,
;618:1.71188899,1.70991653,1.70794462,1.70597325,1.70400241,1.70203209,1.70006228,1.69809297,
;619:1.69612416,1.69415584,1.69218799,1.69022062,1.68825372,1.68628727,1.68432127,1.68235571,
;620:1.68039058,1.67842588,1.67646160,1.67449772,1.67253424,1.67057116,1.66860847,1.66664615,
;621:1.66468420,1.66272262,1.66076139,1.65880050,1.65683996,1.65487975,1.65291986,1.65096028,
;622:1.64900102,1.64704205,1.64508338,1.64312500,1.64116689,1.63920905,1.63725148,1.63529416,
;623:1.63333709,1.63138026,1.62942366,1.62746728,1.62551112,1.62355517,1.62159943,1.61964388,
;624:1.61768851,1.61573332,1.61377831,1.61182346,1.60986877,1.60791422,1.60595982,1.60400556,
;625:1.60205142,1.60009739,1.59814349,1.59618968,1.59423597,1.59228235,1.59032882,1.58837536,
;626:1.58642196,1.58446863,1.58251535,1.58056211,1.57860891,1.57665574,1.57470259,1.57274945,
;627:1.57079633,1.56884320,1.56689007,1.56493692,1.56298375,1.56103055,1.55907731,1.55712403,
;628:1.55517069,1.55321730,1.55126383,1.54931030,1.54735668,1.54540297,1.54344917,1.54149526,
;629:1.53954124,1.53758710,1.53563283,1.53367843,1.53172389,1.52976919,1.52781434,1.52585933,
;630:1.52390414,1.52194878,1.51999323,1.51803748,1.51608153,1.51412537,1.51216900,1.51021240,
;631:1.50825556,1.50629849,1.50434117,1.50238360,1.50042576,1.49846765,1.49650927,1.49455060,
;632:1.49259163,1.49063237,1.48867280,1.48671291,1.48475270,1.48279215,1.48083127,1.47887004,
;633:1.47690845,1.47494650,1.47298419,1.47102149,1.46905841,1.46709493,1.46513106,1.46316677,
;634:1.46120207,1.45923694,1.45727138,1.45530538,1.45333893,1.45137203,1.44940466,1.44743682,
;635:1.44546850,1.44349969,1.44153038,1.43956057,1.43759024,1.43561940,1.43364803,1.43167612,
;636:1.42970367,1.42773066,1.42575709,1.42378296,1.42180825,1.41983295,1.41785705,1.41588056,
;637:1.41390346,1.41192573,1.40994738,1.40796840,1.40598877,1.40400849,1.40202755,1.40004594,
;638:1.39806365,1.39608068,1.39409701,1.39211264,1.39012756,1.38814175,1.38615522,1.38416795,
;639:1.38217994,1.38019117,1.37820164,1.37621134,1.37422025,1.37222837,1.37023570,1.36824222,
;640:1.36624792,1.36425280,1.36225684,1.36026004,1.35826239,1.35626387,1.35426449,1.35226422,
;641:1.35026307,1.34826101,1.34625805,1.34425418,1.34224937,1.34024364,1.33823695,1.33622932,
;642:1.33422072,1.33221114,1.33020059,1.32818904,1.32617649,1.32416292,1.32214834,1.32013273,
;643:1.31811607,1.31609837,1.31407960,1.31205976,1.31003885,1.30801684,1.30599373,1.30396951,
;644:1.30194417,1.29991770,1.29789009,1.29586133,1.29383141,1.29180031,1.28976803,1.28773456,
;645:1.28569989,1.28366400,1.28162688,1.27958854,1.27754894,1.27550809,1.27346597,1.27142257,
;646:1.26937788,1.26733189,1.26528459,1.26323597,1.26118602,1.25913471,1.25708205,1.25502803,
;647:1.25297262,1.25091583,1.24885763,1.24679802,1.24473698,1.24267450,1.24061058,1.23854519,
;648:1.23647833,1.23440999,1.23234015,1.23026880,1.22819593,1.22612152,1.22404557,1.22196806,
;649:1.21988898,1.21780832,1.21572606,1.21364219,1.21155670,1.20946958,1.20738080,1.20529037,
;650:1.20319826,1.20110447,1.19900898,1.19691177,1.19481283,1.19271216,1.19060973,1.18850553,
;651:1.18639955,1.18429178,1.18218219,1.18007079,1.17795754,1.17584244,1.17372548,1.17160663,
;652:1.16948589,1.16736324,1.16523866,1.16311215,1.16098368,1.15885323,1.15672081,1.15458638,
;653:1.15244994,1.15031147,1.14817095,1.14602836,1.14388370,1.14173695,1.13958808,1.13743709,
;654:1.13528396,1.13312866,1.13097119,1.12881153,1.12664966,1.12448556,1.12231921,1.12015061,
;655:1.11797973,1.11580656,1.11363107,1.11145325,1.10927308,1.10709055,1.10490563,1.10271831,
;656:1.10052856,1.09833638,1.09614174,1.09394462,1.09174500,1.08954287,1.08733820,1.08513098,
;657:1.08292118,1.08070879,1.07849378,1.07627614,1.07405585,1.07183287,1.06960721,1.06737882,
;658:1.06514770,1.06291382,1.06067715,1.05843769,1.05619540,1.05395026,1.05170226,1.04945136,
;659:1.04719755,1.04494080,1.04268110,1.04041841,1.03815271,1.03588399,1.03361221,1.03133735,
;660:1.02905939,1.02677830,1.02449407,1.02220665,1.01991603,1.01762219,1.01532509,1.01302471,
;661:1.01072102,1.00841400,1.00610363,1.00378986,1.00147268,0.99915206,0.99682798,0.99450039,
;662:0.99216928,0.98983461,0.98749636,0.98515449,0.98280898,0.98045980,0.97810691,0.97575030,
;663:0.97338991,0.97102573,0.96865772,0.96628585,0.96391009,0.96153040,0.95914675,0.95675912,
;664:0.95436745,0.95197173,0.94957191,0.94716796,0.94475985,0.94234754,0.93993099,0.93751017,
;665:0.93508504,0.93265556,0.93022170,0.92778341,0.92534066,0.92289341,0.92044161,0.91798524,
;666:0.91552424,0.91305858,0.91058821,0.90811309,0.90563319,0.90314845,0.90065884,0.89816430,
;667:0.89566479,0.89316028,0.89065070,0.88813602,0.88561619,0.88309116,0.88056088,0.87802531,
;668:0.87548438,0.87293806,0.87038629,0.86782901,0.86526619,0.86269775,0.86012366,0.85754385,
;669:0.85495827,0.85236686,0.84976956,0.84716633,0.84455709,0.84194179,0.83932037,0.83669277,
;670:0.83405893,0.83141877,0.82877225,0.82611928,0.82345981,0.82079378,0.81812110,0.81544172,
;671:0.81275556,0.81006255,0.80736262,0.80465570,0.80194171,0.79922057,0.79649221,0.79375655,
;672:0.79101352,0.78826302,0.78550497,0.78273931,0.77996593,0.77718475,0.77439569,0.77159865,
;673:0.76879355,0.76598029,0.76315878,0.76032891,0.75749061,0.75464376,0.75178826,0.74892402,
;674:0.74605092,0.74316887,0.74027775,0.73737744,0.73446785,0.73154885,0.72862033,0.72568217,
;675:0.72273425,0.71977644,0.71680861,0.71383064,0.71084240,0.70784376,0.70483456,0.70181469,
;676:0.69878398,0.69574231,0.69268952,0.68962545,0.68654996,0.68346288,0.68036406,0.67725332,
;677:0.67413051,0.67099544,0.66784794,0.66468783,0.66151492,0.65832903,0.65512997,0.65191753,
;678:0.64869151,0.64545170,0.64219789,0.63892987,0.63564741,0.63235028,0.62903824,0.62571106,
;679:0.62236849,0.61901027,0.61563615,0.61224585,0.60883911,0.60541564,0.60197515,0.59851735,
;680:0.59504192,0.59154856,0.58803694,0.58450672,0.58095756,0.57738911,0.57380101,0.57019288,
;681:0.56656433,0.56291496,0.55924437,0.55555212,0.55183778,0.54810089,0.54434099,0.54055758,
;682:0.53675018,0.53291825,0.52906127,0.52517867,0.52126988,0.51733431,0.51337132,0.50938028,
;683:0.50536051,0.50131132,0.49723200,0.49312177,0.48897987,0.48480547,0.48059772,0.47635573,
;684:0.47207859,0.46776530,0.46341487,0.45902623,0.45459827,0.45012983,0.44561967,0.44106652,
;685:0.43646903,0.43182577,0.42713525,0.42239588,0.41760600,0.41276385,0.40786755,0.40291513,
;686:0.39790449,0.39283339,0.38769946,0.38250016,0.37723277,0.37189441,0.36648196,0.36099209,
;687:0.35542120,0.34976542,0.34402054,0.33818204,0.33224495,0.32620390,0.32005298,0.31378574,
;688:0.30739505,0.30087304,0.29421096,0.28739907,0.28042645,0.27328078,0.26594810,0.25841250,
;689:0.25065566,0.24265636,0.23438976,0.22582651,0.21693146,0.20766198,0.19796546,0.18777575,
;690:0.17700769,0.16554844,0.15324301,0.13986823,0.12508152,0.10830610,0.08841715,0.06251018,
;691:}
;692:
;693:double acos( double x ) {
;694:	int index;
;695:
;696:	if (x < -1)
;697:		x = -1;
;698:	if (x > 1)
;699:		x = 1;
;700:	index = (float) (1.0 + x) * 511.9;
;701:	return acostable[index];
;702:}
;703:
;704:double atan2( double y, double x ) {
;705:	float	base;
;706:	float	temp;
;707:	float	dir;
;708:	float	test;
;709:	int		i;
;710:
;711:	if ( x < 0 ) {
;712:		if ( y >= 0 ) {
;713:			// quad 1
;714:			base = M_PI / 2;
;715:			temp = x;
;716:			x = y;
;717:			y = -temp;
;718:		} else {
;719:			// quad 2
;720:			base = M_PI;
;721:			x = -x;
;722:			y = -y;
;723:		}
;724:	} else {
;725:		if ( y < 0 ) {
;726:			// quad 3
;727:			base = 3 * M_PI / 2;
;728:			temp = x;
;729:			x = -y;
;730:			y = temp;
;731:		}
;732:	}
;733:
;734:	if ( y > x ) {
;735:		base += M_PI/2;
;736:		temp = x;
;737:		x = y;
;738:		y = temp;
;739:		dir = -1;
;740:	} else {
;741:		dir = 1;
;742:	}
;743:
;744:	// calcualte angle in octant 0
;745:	if ( x == 0 ) {
;746:		return base;
;747:	}
;748:	y /= x;
;749:
;750:	for ( i = 0 ; i < 512 ; i++ ) {
;751:		test = sintable[i] / sintable[1023-i];
;752:		if ( test > y ) {
;753:			break;
;754:		}
;755:	}
;756:
;757:	return base + dir * i * ( M_PI/2048); 
;758:}
;759:
;760:
;761:#endif
;762:
;763:double tan( double x ) {
line 764
;764:	return sin(x) / cos(x);
ADDRFP4 0
INDIRF4
ARGF4
ADDRLP4 0
ADDRGP4 sin
CALLF4
ASGNF4
ADDRFP4 0
INDIRF4
ARGF4
ADDRLP4 4
ADDRGP4 cos
CALLF4
ASGNF4
ADDRLP4 0
INDIRF4
ADDRLP4 4
INDIRF4
DIVF4
RETF4
LABELV $193
endproc tan 8 4
data
align 4
LABELV randSeed
byte 4 0
export srand
code
proc srand 0 0
line 770
;765:}
;766:
;767:
;768:static int randSeed = 0;
;769:
;770:void	srand( unsigned seed ) {
line 771
;771:	randSeed = seed;
ADDRGP4 randSeed
ADDRFP4 0
INDIRU4
CVUI4 4
ASGNI4
line 772
;772:}
LABELV $194
endproc srand 0 0
export rand
proc rand 4 0
line 774
;773:
;774:int		rand( void ) {
line 775
;775:	randSeed = (69069 * randSeed + 1);
ADDRLP4 0
ADDRGP4 randSeed
ASGNP4
ADDRLP4 0
INDIRP4
CNSTI4 69069
ADDRLP4 0
INDIRP4
INDIRI4
MULI4
CNSTI4 1
ADDI4
ASGNI4
line 776
;776:	return randSeed & 0x7fff;
ADDRGP4 randSeed
INDIRI4
CNSTI4 32767
BANDI4
RETI4
LABELV $195
endproc rand 4 0
export atof
proc atof 32 0
line 779
;777:}
;778:
;779:double atof( const char *string ) {
ADDRGP4 $198
JUMPV
LABELV $197
line 786
;780:	float sign;
;781:	float value;
;782:	int		c;
;783:
;784:
;785:	// skip whitespace
;786:	while ( *string <= ' ' ) {
line 787
;787:		if ( !*string ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $200
line 788
;788:			return 0;
CNSTF4 0
RETF4
ADDRGP4 $196
JUMPV
LABELV $200
line 790
;789:		}
;790:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 791
;791:	}
LABELV $198
line 786
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $197
line 794
;792:
;793:	// check sign
;794:	switch ( *string ) {
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 43
EQI4 $205
ADDRLP4 12
INDIRI4
CNSTI4 45
EQI4 $206
ADDRGP4 $202
JUMPV
LABELV $205
line 796
;795:	case '+':
;796:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 797
;797:		sign = 1;
ADDRLP4 8
CNSTF4 1065353216
ASGNF4
line 798
;798:		break;
ADDRGP4 $203
JUMPV
LABELV $206
line 800
;799:	case '-':
;800:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 801
;801:		sign = -1;
ADDRLP4 8
CNSTF4 3212836864
ASGNF4
line 802
;802:		break;
ADDRGP4 $203
JUMPV
LABELV $202
line 804
;803:	default:
;804:		sign = 1;
ADDRLP4 8
CNSTF4 1065353216
ASGNF4
line 805
;805:		break;
LABELV $203
line 809
;806:	}
;807:
;808:	// read digits
;809:	value = 0;
ADDRLP4 4
CNSTF4 0
ASGNF4
line 810
;810:	c = string[0];
ADDRLP4 0
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 811
;811:	if ( c != '.' ) {
ADDRLP4 0
INDIRI4
CNSTI4 46
EQI4 $207
LABELV $209
line 812
;812:		do {
line 813
;813:			c = *string++;
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 814
;814:			if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $214
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $212
LABELV $214
line 815
;815:				break;
ADDRGP4 $208
JUMPV
LABELV $212
line 817
;816:			}
;817:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 818
;818:			value = value * 10 + c;
ADDRLP4 4
CNSTF4 1092616192
ADDRLP4 4
INDIRF4
MULF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDF4
ASGNF4
line 819
;819:		} while ( 1 );
LABELV $210
ADDRGP4 $209
JUMPV
line 820
;820:	} else {
ADDRGP4 $208
JUMPV
LABELV $207
line 821
;821:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 822
;822:	}
LABELV $208
line 825
;823:
;824:	// check for decimal point
;825:	if ( c == '.' ) {
ADDRLP4 0
INDIRI4
CNSTI4 46
NEI4 $215
line 828
;826:		double fraction;
;827:
;828:		fraction = 0.1;
ADDRLP4 20
CNSTF4 1036831949
ASGNF4
LABELV $217
line 829
;829:		do {
line 830
;830:			c = *string++;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 831
;831:			if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $222
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $220
LABELV $222
line 832
;832:				break;
ADDRGP4 $219
JUMPV
LABELV $220
line 834
;833:			}
;834:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 835
;835:			value += c * fraction;
ADDRLP4 4
ADDRLP4 4
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDRLP4 20
INDIRF4
MULF4
ADDF4
ASGNF4
line 836
;836:			fraction *= 0.1;
ADDRLP4 20
CNSTF4 1036831949
ADDRLP4 20
INDIRF4
MULF4
ASGNF4
line 837
;837:		} while ( 1 );
LABELV $218
ADDRGP4 $217
JUMPV
LABELV $219
line 839
;838:
;839:	}
LABELV $215
line 843
;840:
;841:	// not handling 10e10 notation...
;842:
;843:	return value * sign;
ADDRLP4 4
INDIRF4
ADDRLP4 8
INDIRF4
MULF4
RETF4
LABELV $196
endproc atof 32 0
export _atof
proc _atof 36 0
line 846
;844:}
;845:
;846:double _atof( const char **stringPtr ) {
line 850
;847:	const char	*string;
;848:	float sign;
;849:	float value;
;850:	int		c = '0';
ADDRLP4 0
CNSTI4 48
ASGNI4
line 852
;851:
;852:	string = *stringPtr;
ADDRLP4 4
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
ADDRGP4 $225
JUMPV
LABELV $224
line 855
;853:
;854:	// skip whitespace
;855:	while ( *string <= ' ' ) {
line 856
;856:		if ( !*string ) {
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $227
line 857
;857:			*stringPtr = string;
ADDRFP4 0
INDIRP4
ADDRLP4 4
INDIRP4
ASGNP4
line 858
;858:			return 0;
CNSTF4 0
RETF4
ADDRGP4 $223
JUMPV
LABELV $227
line 860
;859:		}
;860:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 861
;861:	}
LABELV $225
line 855
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $224
line 864
;862:
;863:	// check sign
;864:	switch ( *string ) {
ADDRLP4 16
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 43
EQI4 $232
ADDRLP4 16
INDIRI4
CNSTI4 45
EQI4 $233
ADDRGP4 $229
JUMPV
LABELV $232
line 866
;865:	case '+':
;866:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 867
;867:		sign = 1;
ADDRLP4 12
CNSTF4 1065353216
ASGNF4
line 868
;868:		break;
ADDRGP4 $230
JUMPV
LABELV $233
line 870
;869:	case '-':
;870:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 871
;871:		sign = -1;
ADDRLP4 12
CNSTF4 3212836864
ASGNF4
line 872
;872:		break;
ADDRGP4 $230
JUMPV
LABELV $229
line 874
;873:	default:
;874:		sign = 1;
ADDRLP4 12
CNSTF4 1065353216
ASGNF4
line 875
;875:		break;
LABELV $230
line 879
;876:	}
;877:
;878:	// read digits
;879:	value = 0;
ADDRLP4 8
CNSTF4 0
ASGNF4
line 880
;880:	if ( string[0] != '.' ) {
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 46
EQI4 $234
LABELV $236
line 881
;881:		do {
line 882
;882:			c = *string++;
ADDRLP4 24
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 883
;883:			if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $241
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $239
LABELV $241
line 884
;884:				break;
ADDRGP4 $238
JUMPV
LABELV $239
line 886
;885:			}
;886:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 887
;887:			value = value * 10 + c;
ADDRLP4 8
CNSTF4 1092616192
ADDRLP4 8
INDIRF4
MULF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDF4
ASGNF4
line 888
;888:		} while ( 1 );
LABELV $237
ADDRGP4 $236
JUMPV
LABELV $238
line 889
;889:	}
LABELV $234
line 892
;890:
;891:	// check for decimal point
;892:	if ( c == '.' ) {
ADDRLP4 0
INDIRI4
CNSTI4 46
NEI4 $242
line 895
;893:		double fraction;
;894:
;895:		fraction = 0.1;
ADDRLP4 24
CNSTF4 1036831949
ASGNF4
LABELV $244
line 896
;896:		do {
line 897
;897:			c = *string++;
ADDRLP4 28
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 28
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 28
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 898
;898:			if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $249
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $247
LABELV $249
line 899
;899:				break;
ADDRGP4 $246
JUMPV
LABELV $247
line 901
;900:			}
;901:			c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 902
;902:			value += c * fraction;
ADDRLP4 8
ADDRLP4 8
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
ADDRLP4 24
INDIRF4
MULF4
ADDF4
ASGNF4
line 903
;903:			fraction *= 0.1;
ADDRLP4 24
CNSTF4 1036831949
ADDRLP4 24
INDIRF4
MULF4
ASGNF4
line 904
;904:		} while ( 1 );
LABELV $245
ADDRGP4 $244
JUMPV
LABELV $246
line 906
;905:
;906:	}
LABELV $242
line 909
;907:
;908:	// not handling 10e10 notation...
;909:	*stringPtr = string;
ADDRFP4 0
INDIRP4
ADDRLP4 4
INDIRP4
ASGNP4
line 911
;910:
;911:	return value * sign;
ADDRLP4 8
INDIRF4
ADDRLP4 12
INDIRF4
MULF4
RETF4
LABELV $223
endproc _atof 36 0
export strtod
proc strtod 60 12
line 929
;912:}
;913:
;914:/*
;915:==============
;916:strtod
;917:
;918:Without an errno variable, this is a fair bit less useful than it is in libc
;919:but it's still a fair bit more capable than atof or _atof
;920:Handles inf[inity], nan (ignoring case), hexadecimals, and decimals
;921:Handles decimal exponents like 10e10 and hex exponents like 0x7f8p20
;922:10e10 == 10000000000 (power of ten)
;923:0x7f8p20 == 0x7f800000 (decimal power of two)
;924:The variable pointed to by endptr will hold the location of the first character
;925:in the nptr string that was not used in the conversion
;926:==============
;927:*/
;928:double strtod( const char *nptr, const char **endptr )
;929:{
line 931
;930:	double res;
;931:	qboolean neg = qfalse;
ADDRLP4 4
CNSTI4 0
ASGNI4
ADDRGP4 $252
JUMPV
LABELV $251
line 935
;932:
;933:	// skip whitespace
;934:	while( isspace( *nptr ) )
;935:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $252
line 934
ADDRLP4 8
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 32
EQI4 $251
ADDRLP4 8
INDIRI4
CNSTI4 12
EQI4 $251
ADDRLP4 8
INDIRI4
CNSTI4 10
EQI4 $251
ADDRLP4 8
INDIRI4
CNSTI4 13
EQI4 $251
ADDRLP4 8
INDIRI4
CNSTI4 9
EQI4 $251
ADDRLP4 8
INDIRI4
CNSTI4 11
EQI4 $251
line 938
;936:
;937:	// special string parsing
;938:	if( Q_stricmpn( nptr, "nan", 3 ) == 0 )
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $256
ARGP4
CNSTI4 3
ARGI4
ADDRLP4 12
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 0
NEI4 $254
line 939
;939:	{
line 941
;940:		floatint_t nan;
;941:		if( endptr == NULL )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $257
line 942
;942:		{
line 943
;943:			nan.ui = 0x7fffffff;
ADDRLP4 16
CNSTU4 2147483647
ASGNU4
line 944
;944:			return nan.f;
ADDRLP4 16
INDIRF4
RETF4
ADDRGP4 $250
JUMPV
LABELV $257
line 946
;945:		}
;946:		*endptr = &nptr[3];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
ASGNP4
line 952
;947:		// nan can be followed by a bracketed number (in hex, octal,
;948:		// or decimal) which is then put in the mantissa
;949:		// this can be used to generate signalling or quiet NaNs, for
;950:		// example (though I doubt it'll ever be used)
;951:		// note that nan(0) is infinity!
;952:		if( nptr[3] == '(' )
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
INDIRI1
CVII4 1
CNSTI4 40
NEI4 $259
line 953
;953:		{
line 955
;954:			const char *end;
;955:			int mantissa = strtol( &nptr[4], &end, 0 );
ADDRFP4 0
INDIRP4
CNSTI4 4
ADDP4
ARGP4
ADDRLP4 24
ARGP4
CNSTI4 0
ARGI4
ADDRLP4 28
ADDRGP4 strtol
CALLI4
ASGNI4
ADDRLP4 20
ADDRLP4 28
INDIRI4
ASGNI4
line 956
;956:			if( *end == ')' )
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
CNSTI4 41
NEI4 $261
line 957
;957:			{
line 958
;958:				nan.ui = 0x7f800000 | ( mantissa & 0x7fffff );
ADDRLP4 16
ADDRLP4 20
INDIRI4
CNSTI4 8388607
BANDI4
CNSTI4 2139095040
BORI4
CVIU4 4
ASGNU4
line 959
;959:				if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $263
line 960
;960:					*endptr = &end[1];
ADDRFP4 4
INDIRP4
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $263
line 961
;961:				return nan.f;
ADDRLP4 16
INDIRF4
RETF4
ADDRGP4 $250
JUMPV
LABELV $261
line 963
;962:			}
;963:		}
LABELV $259
line 964
;964:		nan.ui = 0x7fffffff;
ADDRLP4 16
CNSTU4 2147483647
ASGNU4
line 965
;965:		return nan.f;
ADDRLP4 16
INDIRF4
RETF4
ADDRGP4 $250
JUMPV
LABELV $254
line 967
;966:	}
;967:	if( Q_stricmpn( nptr, "inf", 3 ) == 0 )
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $267
ARGP4
CNSTI4 3
ARGI4
ADDRLP4 16
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
NEI4 $265
line 968
;968:	{
line 970
;969:		floatint_t inf;
;970:		inf.ui = 0x7f800000;
ADDRLP4 20
CNSTU4 2139095040
ASGNU4
line 971
;971:		if( endptr == NULL )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $268
line 972
;972:			return inf.f;
ADDRLP4 20
INDIRF4
RETF4
ADDRGP4 $250
JUMPV
LABELV $268
line 973
;973:		if( Q_stricmpn( &nptr[3], "inity", 5 ) == 0 )
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
ARGP4
ADDRGP4 $272
ARGP4
CNSTI4 5
ARGI4
ADDRLP4 24
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 0
NEI4 $270
line 974
;974:			*endptr = &nptr[8];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
CNSTI4 8
ADDP4
ASGNP4
ADDRGP4 $271
JUMPV
LABELV $270
line 976
;975:		else
;976:			*endptr = &nptr[3];
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
CNSTI4 3
ADDP4
ASGNP4
LABELV $271
line 977
;977:		return inf.f;
ADDRLP4 20
INDIRF4
RETF4
ADDRGP4 $250
JUMPV
LABELV $265
line 982
;978:	}
;979:
;980:	// normal numeric parsing
;981:	// sign
;982:	if( *nptr == '-' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $273
line 983
;983:	{
line 984
;984:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 985
;985:		neg = qtrue;
ADDRLP4 4
CNSTI4 1
ASGNI4
line 986
;986:	}
ADDRGP4 $274
JUMPV
LABELV $273
line 987
;987:	else if( *nptr == '+' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 43
NEI4 $275
line 988
;988:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $275
LABELV $274
line 990
;989:	// hex
;990:	if( Q_stricmpn( nptr, "0x", 2 ) == 0 )
ADDRFP4 0
INDIRP4
ARGP4
ADDRGP4 $279
ARGP4
CNSTI4 2
ARGI4
ADDRLP4 20
ADDRGP4 Q_stricmpn
CALLI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
NEI4 $277
line 991
;991:	{
line 993
;992:		// track if we use any digits
;993:		const char *s = &nptr[1], *end = s;
ADDRLP4 28
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 24
ADDRLP4 28
INDIRP4
ASGNP4
line 994
;994:		nptr += 2;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 2
ADDP4
ASGNP4
line 995
;995:		res = 0;
ADDRLP4 0
CNSTF4 0
ASGNF4
ADDRGP4 $281
JUMPV
LABELV $280
line 997
;996:		while( qtrue )
;997:		{
line 998
;998:			if( isdigit( *nptr ) )
ADDRLP4 32
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 48
LTI4 $283
ADDRLP4 32
INDIRI4
CNSTI4 57
GTI4 $283
line 999
;999:				res = 16 * res + ( *nptr++ - '0' );
ADDRLP4 36
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 36
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1098907648
ADDRLP4 0
INDIRF4
MULF4
ADDRLP4 36
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
CVIF4 4
ADDF4
ASGNF4
ADDRGP4 $284
JUMPV
LABELV $283
line 1000
;1000:			else if( *nptr >= 'A' && *nptr <= 'F' )
ADDRLP4 40
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 65
LTI4 $285
ADDRLP4 40
INDIRI4
CNSTI4 70
GTI4 $285
line 1001
;1001:				res = 16 * res + 10 + *nptr++ - 'A';
ADDRLP4 44
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 44
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1098907648
ADDRLP4 0
INDIRF4
MULF4
CNSTF4 1092616192
ADDF4
ADDRLP4 44
INDIRP4
INDIRI1
CVII4 1
CVIF4 4
ADDF4
CNSTF4 1115815936
SUBF4
ASGNF4
ADDRGP4 $286
JUMPV
LABELV $285
line 1002
;1002:			else if( *nptr >= 'a' && *nptr <= 'f' )
ADDRLP4 48
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 97
LTI4 $282
ADDRLP4 48
INDIRI4
CNSTI4 102
GTI4 $282
line 1003
;1003:				res = 16 * res + 10 + *nptr++ - 'a';
ADDRLP4 52
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 52
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1098907648
ADDRLP4 0
INDIRF4
MULF4
CNSTF4 1092616192
ADDF4
ADDRLP4 52
INDIRP4
INDIRI1
CVII4 1
CVIF4 4
ADDF4
CNSTF4 1120010240
SUBF4
ASGNF4
line 1005
;1004:			else
;1005:				break;
LABELV $288
LABELV $286
LABELV $284
line 1006
;1006:		}
LABELV $281
line 996
ADDRGP4 $280
JUMPV
LABELV $282
line 1008
;1007:		// if nptr moved, save it
;1008:		if( end + 1 < nptr )
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $289
line 1009
;1009:			end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $289
line 1010
;1010:		if( *nptr == '.' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 46
NEI4 $291
line 1011
;1011:		{
line 1013
;1012:			float place;
;1013:			nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1018
;1014:			// 1.0 / 16.0 == 0.0625
;1015:			// I don't expect the float accuracy to hold out for
;1016:			// very long but since we need to know the length of
;1017:			// the string anyway we keep on going regardless
;1018:			for( place = 0.0625;; place /= 16.0 )
ADDRLP4 32
CNSTF4 1031798784
ASGNF4
LABELV $293
line 1019
;1019:			{
line 1020
;1020:				if( isdigit( *nptr ) )
ADDRLP4 36
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 48
LTI4 $297
ADDRLP4 36
INDIRI4
CNSTI4 57
GTI4 $297
line 1021
;1021:					res += place * ( *nptr++ - '0' );
ADDRLP4 40
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 40
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 32
INDIRF4
ADDRLP4 40
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
CVIF4 4
MULF4
ADDF4
ASGNF4
ADDRGP4 $298
JUMPV
LABELV $297
line 1022
;1022:				else if( *nptr >= 'A' && *nptr <= 'F' )
ADDRLP4 44
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 65
LTI4 $299
ADDRLP4 44
INDIRI4
CNSTI4 70
GTI4 $299
line 1023
;1023:					res += place * ( 10 + *nptr++ - 'A' );
ADDRLP4 48
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 48
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 32
INDIRF4
ADDRLP4 48
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 65
SUBI4
CVIF4 4
MULF4
ADDF4
ASGNF4
ADDRGP4 $300
JUMPV
LABELV $299
line 1024
;1024:				else if( *nptr >= 'a' && *nptr <= 'f' )
ADDRLP4 52
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 52
INDIRI4
CNSTI4 97
LTI4 $295
ADDRLP4 52
INDIRI4
CNSTI4 102
GTI4 $295
line 1025
;1025:					res += place * ( 10 + *nptr++ - 'a' );
ADDRLP4 56
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 56
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 32
INDIRF4
ADDRLP4 56
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 97
SUBI4
CVIF4 4
MULF4
ADDF4
ASGNF4
line 1027
;1026:				else
;1027:					break;
LABELV $302
LABELV $300
LABELV $298
line 1028
;1028:			}
LABELV $294
line 1018
ADDRLP4 32
ADDRLP4 32
INDIRF4
CNSTF4 1098907648
DIVF4
ASGNF4
ADDRGP4 $293
JUMPV
LABELV $295
line 1029
;1029:			if( end < nptr )
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $303
line 1030
;1030:				end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $303
line 1031
;1031:		}
LABELV $291
line 1036
;1032:		// parse an optional exponent, representing multiplication
;1033:		// by a power of two
;1034:		// exponents are only valid if we encountered at least one
;1035:		// digit already (and have therefore set end to something)
;1036:		if( end != s && tolower( *nptr ) == 'p' )
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRLP4 28
INDIRP4
CVPU4 4
EQU4 $305
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 32
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRLP4 32
INDIRI4
CNSTI4 112
NEI4 $305
line 1037
;1037:		{
line 1042
;1038:			int exp;
;1039:			float res2;
;1040:			// apparently (confusingly) the exponent should be
;1041:			// decimal
;1042:			exp = strtol( &nptr[1], &end, 10 );
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ARGP4
ADDRLP4 24
ARGP4
CNSTI4 10
ARGI4
ADDRLP4 44
ADDRGP4 strtol
CALLI4
ASGNI4
ADDRLP4 40
ADDRLP4 44
INDIRI4
ASGNI4
line 1043
;1043:			if( &nptr[1] == end )
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
NEU4 $307
line 1044
;1044:			{
line 1046
;1045:				// no exponent
;1046:				if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $309
line 1047
;1047:					*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $309
line 1048
;1048:				return res;
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $250
JUMPV
LABELV $307
line 1050
;1049:			}
;1050:			if( exp > 0 )
ADDRLP4 40
INDIRI4
CNSTI4 0
LEI4 $319
line 1051
;1051:			{
ADDRGP4 $314
JUMPV
LABELV $313
line 1053
;1052:				while( exp-- > 0 )
;1053:				{
line 1054
;1054:					res2 = res * 2;
ADDRLP4 36
CNSTF4 1073741824
ADDRLP4 0
INDIRF4
MULF4
ASGNF4
line 1056
;1055:					// check for infinity
;1056:					if( res2 <= res )
ADDRLP4 36
INDIRF4
ADDRLP4 0
INDIRF4
GTF4 $316
line 1057
;1057:						break;
ADDRGP4 $312
JUMPV
LABELV $316
line 1058
;1058:					res = res2;
ADDRLP4 0
ADDRLP4 36
INDIRF4
ASGNF4
line 1059
;1059:				}
LABELV $314
line 1052
ADDRLP4 48
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 40
ADDRLP4 48
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 0
GTI4 $313
line 1060
;1060:			}
ADDRGP4 $312
JUMPV
line 1062
;1061:			else
;1062:			{
LABELV $318
line 1064
;1063:				while( exp++ < 0 )
;1064:				{
line 1065
;1065:					res2 = res / 2;
ADDRLP4 36
ADDRLP4 0
INDIRF4
CNSTF4 1073741824
DIVF4
ASGNF4
line 1067
;1066:					// check for underflow
;1067:					if( res2 >= res )
ADDRLP4 36
INDIRF4
ADDRLP4 0
INDIRF4
LTF4 $321
line 1068
;1068:						break;
ADDRGP4 $320
JUMPV
LABELV $321
line 1069
;1069:					res = res2;
ADDRLP4 0
ADDRLP4 36
INDIRF4
ASGNF4
line 1070
;1070:				}
LABELV $319
line 1063
ADDRLP4 48
ADDRLP4 40
INDIRI4
ASGNI4
ADDRLP4 40
ADDRLP4 48
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 0
LTI4 $318
LABELV $320
line 1071
;1071:			}
LABELV $312
line 1072
;1072:		}
LABELV $305
line 1073
;1073:		if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $323
line 1074
;1074:			*endptr = end;
ADDRFP4 4
INDIRP4
ADDRLP4 24
INDIRP4
ASGNP4
LABELV $323
line 1075
;1075:		return res;
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $250
JUMPV
LABELV $277
line 1079
;1076:	}
;1077:	// decimal
;1078:	else
;1079:	{
line 1081
;1080:		// track if we find any digits
;1081:		const char *end = nptr, *p = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
ADDRLP4 28
ADDRFP4 0
INDIRP4
ASGNP4
line 1083
;1082:		// this is most of the work
;1083:		for( res = 0; isdigit( *nptr );
ADDRLP4 0
CNSTF4 0
ASGNF4
ADDRGP4 $328
JUMPV
LABELV $325
line 1084
;1084:			res = 10 * res + *nptr++ - '0' );
LABELV $326
ADDRLP4 32
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 32
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
CNSTF4 1092616192
ADDRLP4 0
INDIRF4
MULF4
ADDRLP4 32
INDIRP4
INDIRI1
CVII4 1
CVIF4 4
ADDF4
CNSTF4 1111490560
SUBF4
ASGNF4
LABELV $328
line 1083
ADDRLP4 36
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 36
INDIRI4
CNSTI4 48
LTI4 $329
ADDRLP4 36
INDIRI4
CNSTI4 57
LEI4 $325
LABELV $329
line 1086
;1085:		// if nptr moved, we read something
;1086:		if( end < nptr )
ADDRLP4 24
INDIRP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $330
line 1087
;1087:			end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $330
line 1088
;1088:		if( *nptr == '.' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 46
NEI4 $332
line 1089
;1089:		{
line 1092
;1090:			// fractional part
;1091:			float place;
;1092:			nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1093
;1093:			for( place = 0.1; isdigit( *nptr ); place /= 10.0 )
ADDRLP4 40
CNSTF4 1036831949
ASGNF4
ADDRGP4 $337
JUMPV
LABELV $334
line 1094
;1094:				res += ( *nptr++ - '0' ) * place;
ADDRLP4 44
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 44
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 0
INDIRF4
ADDRLP4 44
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
CVIF4 4
ADDRLP4 40
INDIRF4
MULF4
ADDF4
ASGNF4
LABELV $335
line 1093
ADDRLP4 40
ADDRLP4 40
INDIRF4
CNSTF4 1092616192
DIVF4
ASGNF4
LABELV $337
ADDRLP4 48
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 48
INDIRI4
CNSTI4 48
LTI4 $338
ADDRLP4 48
INDIRI4
CNSTI4 57
LEI4 $334
LABELV $338
line 1096
;1095:			// if nptr moved, we read something
;1096:			if( end + 1 < nptr )
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRFP4 0
INDIRP4
CVPU4 4
GEU4 $339
line 1097
;1097:				end = nptr;
ADDRLP4 24
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $339
line 1098
;1098:		}
LABELV $332
line 1102
;1099:		// exponent
;1100:		// meaningless without having already read digits, so check
;1101:		// we've set end to something
;1102:		if( p != end && tolower( *nptr ) == 'e' )
ADDRLP4 28
INDIRP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
EQU4 $341
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 40
ADDRGP4 tolower
CALLI4
ASGNI4
ADDRLP4 40
INDIRI4
CNSTI4 101
NEI4 $341
line 1103
;1103:		{
line 1106
;1104:			int exp;
;1105:			float res10;
;1106:			exp = strtol( &nptr[1], &end, 10 );
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ARGP4
ADDRLP4 24
ARGP4
CNSTI4 10
ARGI4
ADDRLP4 52
ADDRGP4 strtol
CALLI4
ASGNI4
ADDRLP4 48
ADDRLP4 52
INDIRI4
ASGNI4
line 1107
;1107:			if( &nptr[1] == end )
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
CVPU4 4
ADDRLP4 24
INDIRP4
CVPU4 4
NEU4 $343
line 1108
;1108:			{
line 1110
;1109:				// no exponent
;1110:				if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $345
line 1111
;1111:					*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $345
line 1112
;1112:				return res;
ADDRLP4 0
INDIRF4
RETF4
ADDRGP4 $250
JUMPV
LABELV $343
line 1114
;1113:			}
;1114:			if( exp > 0 )
ADDRLP4 48
INDIRI4
CNSTI4 0
LEI4 $347
line 1115
;1115:			{
ADDRGP4 $350
JUMPV
LABELV $349
line 1117
;1116:				while( exp-- > 0 )
;1117:				{
line 1118
;1118:					res10 = res * 10;
ADDRLP4 44
CNSTF4 1092616192
ADDRLP4 0
INDIRF4
MULF4
ASGNF4
line 1120
;1119:					// check for infinity to save us time
;1120:					if( res10 <= res )
ADDRLP4 44
INDIRF4
ADDRLP4 0
INDIRF4
GTF4 $352
line 1121
;1121:						break;
ADDRGP4 $348
JUMPV
LABELV $352
line 1122
;1122:					res = res10;
ADDRLP4 0
ADDRLP4 44
INDIRF4
ASGNF4
line 1123
;1123:				}
LABELV $350
line 1116
ADDRLP4 56
ADDRLP4 48
INDIRI4
ASGNI4
ADDRLP4 48
ADDRLP4 56
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 0
GTI4 $349
line 1124
;1124:			}
ADDRGP4 $348
JUMPV
LABELV $347
line 1125
;1125:			else if( exp < 0 )
ADDRLP4 48
INDIRI4
CNSTI4 0
GEI4 $354
line 1126
;1126:			{
ADDRGP4 $357
JUMPV
LABELV $356
line 1128
;1127:				while( exp++ < 0 )
;1128:				{
line 1129
;1129:					res10 = res / 10;
ADDRLP4 44
ADDRLP4 0
INDIRF4
CNSTF4 1092616192
DIVF4
ASGNF4
line 1133
;1130:					// check for underflow
;1131:					// (test for 0 would probably be just
;1132:					// as good)
;1133:					if( res10 >= res )
ADDRLP4 44
INDIRF4
ADDRLP4 0
INDIRF4
LTF4 $359
line 1134
;1134:						break;
ADDRGP4 $358
JUMPV
LABELV $359
line 1135
;1135:					res = res10;
ADDRLP4 0
ADDRLP4 44
INDIRF4
ASGNF4
line 1136
;1136:				}
LABELV $357
line 1127
ADDRLP4 56
ADDRLP4 48
INDIRI4
ASGNI4
ADDRLP4 48
ADDRLP4 56
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 0
LTI4 $356
LABELV $358
line 1137
;1137:			}
LABELV $354
LABELV $348
line 1138
;1138:		}
LABELV $341
line 1139
;1139:		if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $361
line 1140
;1140:			*endptr = end;
ADDRFP4 4
INDIRP4
ADDRLP4 24
INDIRP4
ASGNP4
LABELV $361
line 1141
;1141:		return res;
ADDRLP4 0
INDIRF4
RETF4
LABELV $250
endproc strtod 60 12
export atoi
proc atoi 28 0
line 1145
;1142:	}
;1143:}
;1144:
;1145:int atoi( const char *string ) {
ADDRGP4 $365
JUMPV
LABELV $364
line 1152
;1146:	int		sign;
;1147:	int		value;
;1148:	int		c;
;1149:
;1150:
;1151:	// skip whitespace
;1152:	while ( *string <= ' ' ) {
line 1153
;1153:		if ( !*string ) {
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $367
line 1154
;1154:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $363
JUMPV
LABELV $367
line 1156
;1155:		}
;1156:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1157
;1157:	}
LABELV $365
line 1152
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $364
line 1160
;1158:
;1159:	// check sign
;1160:	switch ( *string ) {
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 43
EQI4 $372
ADDRLP4 12
INDIRI4
CNSTI4 45
EQI4 $373
ADDRGP4 $369
JUMPV
LABELV $372
line 1162
;1161:	case '+':
;1162:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1163
;1163:		sign = 1;
ADDRLP4 8
CNSTI4 1
ASGNI4
line 1164
;1164:		break;
ADDRGP4 $370
JUMPV
LABELV $373
line 1166
;1165:	case '-':
;1166:		string++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1167
;1167:		sign = -1;
ADDRLP4 8
CNSTI4 -1
ASGNI4
line 1168
;1168:		break;
ADDRGP4 $370
JUMPV
LABELV $369
line 1170
;1169:	default:
;1170:		sign = 1;
ADDRLP4 8
CNSTI4 1
ASGNI4
line 1171
;1171:		break;
LABELV $370
line 1175
;1172:	}
;1173:
;1174:	// read digits
;1175:	value = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $374
line 1176
;1176:	do {
line 1177
;1177:		c = *string++;
ADDRLP4 20
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 20
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1178
;1178:		if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $379
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $377
LABELV $379
line 1179
;1179:			break;
ADDRGP4 $376
JUMPV
LABELV $377
line 1181
;1180:		}
;1181:		c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 1182
;1182:		value = value * 10 + c;
ADDRLP4 4
CNSTI4 10
ADDRLP4 4
INDIRI4
MULI4
ADDRLP4 0
INDIRI4
ADDI4
ASGNI4
line 1183
;1183:	} while ( 1 );
LABELV $375
ADDRGP4 $374
JUMPV
LABELV $376
line 1187
;1184:
;1185:	// not handling 10e10 notation...
;1186:
;1187:	return value * sign;
ADDRLP4 4
INDIRI4
ADDRLP4 8
INDIRI4
MULI4
RETI4
LABELV $363
endproc atoi 28 0
export _atoi
proc _atoi 32 0
line 1191
;1188:}
;1189:
;1190:
;1191:int _atoi( const char **stringPtr ) {
line 1197
;1192:	int		sign;
;1193:	int		value;
;1194:	int		c;
;1195:	const char	*string;
;1196:
;1197:	string = *stringPtr;
ADDRLP4 4
ADDRFP4 0
INDIRP4
INDIRP4
ASGNP4
ADDRGP4 $382
JUMPV
LABELV $381
line 1200
;1198:
;1199:	// skip whitespace
;1200:	while ( *string <= ' ' ) {
line 1201
;1201:		if ( !*string ) {
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $384
line 1202
;1202:			return 0;
CNSTI4 0
RETI4
ADDRGP4 $380
JUMPV
LABELV $384
line 1204
;1203:		}
;1204:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1205
;1205:	}
LABELV $382
line 1200
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 32
LEI4 $381
line 1208
;1206:
;1207:	// check sign
;1208:	switch ( *string ) {
ADDRLP4 16
ADDRLP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 43
EQI4 $389
ADDRLP4 16
INDIRI4
CNSTI4 45
EQI4 $390
ADDRGP4 $386
JUMPV
LABELV $389
line 1210
;1209:	case '+':
;1210:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1211
;1211:		sign = 1;
ADDRLP4 12
CNSTI4 1
ASGNI4
line 1212
;1212:		break;
ADDRGP4 $387
JUMPV
LABELV $390
line 1214
;1213:	case '-':
;1214:		string++;
ADDRLP4 4
ADDRLP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1215
;1215:		sign = -1;
ADDRLP4 12
CNSTI4 -1
ASGNI4
line 1216
;1216:		break;
ADDRGP4 $387
JUMPV
LABELV $386
line 1218
;1217:	default:
;1218:		sign = 1;
ADDRLP4 12
CNSTI4 1
ASGNI4
line 1219
;1219:		break;
LABELV $387
line 1223
;1220:	}
;1221:
;1222:	// read digits
;1223:	value = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $391
line 1224
;1224:	do {
line 1225
;1225:		c = *string++;
ADDRLP4 24
ADDRLP4 4
INDIRP4
ASGNP4
ADDRLP4 4
ADDRLP4 24
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 0
ADDRLP4 24
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 1226
;1226:		if ( c < '0' || c > '9' ) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $396
ADDRLP4 0
INDIRI4
CNSTI4 57
LEI4 $394
LABELV $396
line 1227
;1227:			break;
ADDRGP4 $393
JUMPV
LABELV $394
line 1229
;1228:		}
;1229:		c -= '0';
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 48
SUBI4
ASGNI4
line 1230
;1230:		value = value * 10 + c;
ADDRLP4 8
CNSTI4 10
ADDRLP4 8
INDIRI4
MULI4
ADDRLP4 0
INDIRI4
ADDI4
ASGNI4
line 1231
;1231:	} while ( 1 );
LABELV $392
ADDRGP4 $391
JUMPV
LABELV $393
line 1235
;1232:
;1233:	// not handling 10e10 notation...
;1234:
;1235:	*stringPtr = string;
ADDRFP4 0
INDIRP4
ADDRLP4 4
INDIRP4
ASGNP4
line 1237
;1236:
;1237:	return value * sign;
ADDRLP4 8
INDIRI4
ADDRLP4 12
INDIRI4
MULI4
RETI4
LABELV $380
endproc _atoi 32 0
export strtol
proc strtol 32 0
line 1251
;1238:}
;1239:
;1240:/*
;1241:==============
;1242:strtol
;1243:
;1244:Handles any base from 2 to 36. If base is 0 then it guesses
;1245:decimal, hex, or octal based on the format of the number (leading 0 or 0x)
;1246:Will not overflow - returns LONG_MIN or LONG_MAX as appropriate
;1247:*endptr is set to the location of the first character not used
;1248:==============
;1249:*/
;1250:long strtol( const char *nptr, const char **endptr, int base )
;1251:{
line 1253
;1252:	long res;
;1253:	qboolean pos = qtrue;
ADDRLP4 4
CNSTI4 1
ASGNI4
line 1255
;1254:
;1255:	if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $398
line 1256
;1256:		*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $398
line 1259
;1257:	// bases other than 0, 2, 8, 16 are very rarely used, but they're
;1258:	// not much extra effort to support
;1259:	if( base < 0 || base == 1 || base > 36 )
ADDRLP4 8
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 8
INDIRI4
CNSTI4 0
LTI4 $403
ADDRLP4 8
INDIRI4
CNSTI4 1
EQI4 $403
ADDRLP4 8
INDIRI4
CNSTI4 36
LEI4 $405
LABELV $403
line 1260
;1260:		return 0;
CNSTI4 0
RETI4
ADDRGP4 $397
JUMPV
LABELV $404
line 1263
;1261:	// skip leading whitespace
;1262:	while( isspace( *nptr ) )
;1263:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $405
line 1262
ADDRLP4 12
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 12
INDIRI4
CNSTI4 32
EQI4 $404
ADDRLP4 12
INDIRI4
CNSTI4 12
EQI4 $404
ADDRLP4 12
INDIRI4
CNSTI4 10
EQI4 $404
ADDRLP4 12
INDIRI4
CNSTI4 13
EQI4 $404
ADDRLP4 12
INDIRI4
CNSTI4 9
EQI4 $404
ADDRLP4 12
INDIRI4
CNSTI4 11
EQI4 $404
line 1265
;1264:	// sign
;1265:	if( *nptr == '-' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 45
NEI4 $407
line 1266
;1266:	{
line 1267
;1267:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1268
;1268:		pos = qfalse;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1269
;1269:	}
ADDRGP4 $408
JUMPV
LABELV $407
line 1270
;1270:	else if( *nptr == '+' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 43
NEI4 $409
line 1271
;1271:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $409
LABELV $408
line 1273
;1272:	// look for base-identifying sequences e.g. 0x for hex, 0 for octal
;1273:	if( nptr[0] == '0' )
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
NEI4 $411
line 1274
;1274:	{
line 1275
;1275:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1277
;1276:		// 0 is always a valid digit
;1277:		if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $413
line 1278
;1278:			*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $413
line 1279
;1279:		if( *nptr == 'x' || *nptr == 'X' )
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 120
EQI4 $417
ADDRLP4 16
INDIRI4
CNSTI4 88
NEI4 $415
LABELV $417
line 1280
;1280:		{
line 1281
;1281:			if( base != 0 && base != 16 )
ADDRLP4 20
ADDRFP4 8
INDIRI4
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 0
EQI4 $418
ADDRLP4 20
INDIRI4
CNSTI4 16
EQI4 $418
line 1282
;1282:			{
line 1284
;1283:				// can't be hex, reject x (accept 0)
;1284:				if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $420
line 1285
;1285:					*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $420
line 1286
;1286:				return 0;
CNSTI4 0
RETI4
ADDRGP4 $397
JUMPV
LABELV $418
line 1288
;1287:			}
;1288:			nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1289
;1289:			base = 16;
ADDRFP4 8
CNSTI4 16
ASGNI4
line 1290
;1290:		}
ADDRGP4 $412
JUMPV
LABELV $415
line 1291
;1291:		else if( base == 0 )
ADDRFP4 8
INDIRI4
CNSTI4 0
NEI4 $412
line 1292
;1292:			base = 8;
ADDRFP4 8
CNSTI4 8
ASGNI4
line 1293
;1293:	}
ADDRGP4 $412
JUMPV
LABELV $411
line 1294
;1294:	else if( base == 0 )
ADDRFP4 8
INDIRI4
CNSTI4 0
NEI4 $424
line 1295
;1295:		base = 10;
ADDRFP4 8
CNSTI4 10
ASGNI4
LABELV $424
LABELV $412
line 1296
;1296:	res = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
ADDRGP4 $427
JUMPV
LABELV $426
line 1298
;1297:	while( qtrue )
;1298:	{
line 1300
;1299:		int val;
;1300:		if( isdigit( *nptr ) )
ADDRLP4 20
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 20
INDIRI4
CNSTI4 48
LTI4 $429
ADDRLP4 20
INDIRI4
CNSTI4 57
GTI4 $429
line 1301
;1301:			val = *nptr - '0';
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
ASGNI4
ADDRGP4 $430
JUMPV
LABELV $429
line 1302
;1302:		else if( islower( *nptr ) )
ADDRLP4 24
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 24
INDIRI4
CNSTI4 97
LTI4 $431
ADDRLP4 24
INDIRI4
CNSTI4 122
GTI4 $431
line 1303
;1303:			val = 10 + *nptr - 'a';
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 97
SUBI4
ASGNI4
ADDRGP4 $432
JUMPV
LABELV $431
line 1304
;1304:		else if( isupper( *nptr ) )
ADDRLP4 28
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 28
INDIRI4
CNSTI4 65
LTI4 $428
ADDRLP4 28
INDIRI4
CNSTI4 90
GTI4 $428
line 1305
;1305:			val = 10 + *nptr - 'A';
ADDRLP4 16
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
CNSTI4 10
ADDI4
CNSTI4 65
SUBI4
ASGNI4
line 1307
;1306:		else
;1307:			break;
LABELV $434
LABELV $432
LABELV $430
line 1308
;1308:		if( val >= base )
ADDRLP4 16
INDIRI4
ADDRFP4 8
INDIRI4
LTI4 $435
line 1309
;1309:			break;
ADDRGP4 $428
JUMPV
LABELV $435
line 1312
;1310:		// we go negative because LONG_MIN is further from 0 than
;1311:		// LONG_MAX
;1312:		if( res < ( LONG_MIN + val ) / base )
ADDRLP4 0
INDIRI4
ADDRLP4 16
INDIRI4
CNSTI4 -2147483648
ADDI4
ADDRFP4 8
INDIRI4
DIVI4
GEI4 $437
line 1313
;1313:			res = LONG_MIN; // overflow
ADDRLP4 0
CNSTI4 -2147483648
ASGNI4
ADDRGP4 $438
JUMPV
LABELV $437
line 1315
;1314:		else
;1315:			res = res * base - val;
ADDRLP4 0
ADDRLP4 0
INDIRI4
ADDRFP4 8
INDIRI4
MULI4
ADDRLP4 16
INDIRI4
SUBI4
ASGNI4
LABELV $438
line 1316
;1316:		nptr++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 1317
;1317:		if( endptr )
ADDRFP4 4
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $439
line 1318
;1318:			*endptr = nptr;
ADDRFP4 4
INDIRP4
ADDRFP4 0
INDIRP4
ASGNP4
LABELV $439
line 1319
;1319:	}
LABELV $427
line 1297
ADDRGP4 $426
JUMPV
LABELV $428
line 1320
;1320:	if( pos )
ADDRLP4 4
INDIRI4
CNSTI4 0
EQI4 $441
line 1321
;1321:	{
line 1323
;1322:		// can't represent LONG_MIN positive
;1323:		if( res == LONG_MIN )
ADDRLP4 0
INDIRI4
CNSTI4 -2147483648
NEI4 $443
line 1324
;1324:			res = LONG_MAX;
ADDRLP4 0
CNSTI4 2147483647
ASGNI4
ADDRGP4 $444
JUMPV
LABELV $443
line 1326
;1325:		else
;1326:			res = -res;
ADDRLP4 0
ADDRLP4 0
INDIRI4
NEGI4
ASGNI4
LABELV $444
line 1327
;1327:	}
LABELV $441
line 1328
;1328:	return res;
ADDRLP4 0
INDIRI4
RETI4
LABELV $397
endproc strtol 32 0
export abs
proc abs 4 0
line 1331
;1329:}
;1330:
;1331:int abs( int n ) {
line 1332
;1332:	return n < 0 ? -n : n;
ADDRFP4 0
INDIRI4
CNSTI4 0
GEI4 $447
ADDRLP4 0
ADDRFP4 0
INDIRI4
NEGI4
ASGNI4
ADDRGP4 $448
JUMPV
LABELV $447
ADDRLP4 0
ADDRFP4 0
INDIRI4
ASGNI4
LABELV $448
ADDRLP4 0
INDIRI4
RETI4
LABELV $445
endproc abs 4 0
export fabs
proc fabs 4 0
line 1335
;1333:}
;1334:
;1335:double fabs( double x ) {
line 1336
;1336:	return x < 0 ? -x : x;
ADDRFP4 0
INDIRF4
CNSTF4 0
GEF4 $451
ADDRLP4 0
ADDRFP4 0
INDIRF4
NEGF4
ASGNF4
ADDRGP4 $452
JUMPV
LABELV $451
ADDRLP4 0
ADDRFP4 0
INDIRF4
ASGNF4
LABELV $452
ADDRLP4 0
INDIRF4
RETF4
LABELV $449
endproc fabs 4 0
proc dopr 276 32
line 1475
;1337:}
;1338:
;1339:
;1340:
;1341://=========================================================
;1342:
;1343:/* 
;1344: * New implementation by Patrick Powell and others for vsnprintf.
;1345: * Supports length checking in strings.
;1346:*/
;1347:
;1348:/*
;1349: * Copyright Patrick Powell 1995
;1350: * This code is based on code written by Patrick Powell (papowell@astart.com)
;1351: * It may be used for any purpose as long as this notice remains intact
;1352: * on all source code distributions
;1353: */
;1354:
;1355:/**************************************************************
;1356: * Original:
;1357: * Patrick Powell Tue Apr 11 09:48:21 PDT 1995
;1358: * A bombproof version of doprnt (dopr) included.
;1359: * Sigh.  This sort of thing is always nasty do deal with.  Note that
;1360: * the version here does not include floating point...
;1361: *
;1362: * snprintf() is used instead of sprintf() as it does limit checks
;1363: * for string length.  This covers a nasty loophole.
;1364: *
;1365: * The other functions are there to prevent NULL pointers from
;1366: * causing nast effects.
;1367: *
;1368: * More Recently:
;1369: *  Brandon Long <blong@fiction.net> 9/15/96 for mutt 0.43
;1370: *  This was ugly.  It is still ugly.  I opted out of floating point
;1371: *  numbers, but the formatter understands just about everything
;1372: *  from the normal C string format, at least as far as I can tell from
;1373: *  the Solaris 2.5 printf(3S) man page.
;1374: *
;1375: *  Brandon Long <blong@fiction.net> 10/22/97 for mutt 0.87.1
;1376: *    Ok, added some minimal floating point support, which means this
;1377: *    probably requires libm on most operating systems.  Don't yet
;1378: *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()
;1379: *    was pretty badly broken, it just wasn't being exercised in ways
;1380: *    which showed it, so that's been fixed.  Also, formated the code
;1381: *    to mutt conventions, and removed dead code left over from the
;1382: *    original.  Also, there is now a builtin-test, just compile with:
;1383: *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm
;1384: *    and run snprintf for results.
;1385: * 
;1386: *  Thomas Roessler <roessler@guug.de> 01/27/98 for mutt 0.89i
;1387: *    The PGP code was using unsigned hexadecimal formats. 
;1388: *    Unfortunately, unsigned formats simply didn't work.
;1389: *
;1390: *  Michael Elkins <me@cs.hmc.edu> 03/05/98 for mutt 0.90.8
;1391: *    The original code assumed that both snprintf() and vsnprintf() were
;1392: *    missing.  Some systems only have snprintf() but not vsnprintf(), so
;1393: *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.
;1394: *
;1395: *  Andrew Tridgell (tridge@samba.org) Oct 1998
;1396: *    fixed handling of %.0f
;1397: *    added test for HAVE_LONG_DOUBLE
;1398: *
;1399: *  Russ Allbery <rra@stanford.edu> 2000-08-26
;1400: *    fixed return value to comply with C99
;1401: *    fixed handling of snprintf(NULL, ...)
;1402: *
;1403: *  Hrvoje Niksic <hniksic@arsdigita.com> 2000-11-04
;1404: *    include <config.h> instead of "config.h".
;1405: *    moved TEST_SNPRINTF stuff out of HAVE_SNPRINTF ifdef.
;1406: *    include <stdio.h> for NULL.
;1407: *    added support and test cases for long long.
;1408: *    don't declare argument types to (v)snprintf if stdarg is not used.
;1409: *    use int instead of short int as 2nd arg to va_arg.
;1410: *
;1411: **************************************************************/
;1412:
;1413:/* BDR 2002-01-13  %e and %g were being ignored.  Now do something,
;1414:   if not necessarily correctly */
;1415:
;1416:#if (SIZEOF_LONG_DOUBLE > 0)
;1417:/* #ifdef HAVE_LONG_DOUBLE */
;1418:#define LDOUBLE long double
;1419:#else
;1420:#define LDOUBLE double
;1421:#endif
;1422:
;1423:#if (SIZEOF_LONG_LONG > 0)
;1424:/* #ifdef HAVE_LONG_LONG */
;1425:# define LLONG long long
;1426:#else
;1427:# define LLONG long
;1428:#endif
;1429:
;1430:static int dopr (char *buffer, size_t maxlen, const char *format, 
;1431:                 va_list args);
;1432:static int fmtstr (char *buffer, size_t *currlen, size_t maxlen,
;1433:		   char *value, int flags, int min, int max);
;1434:static int fmtint (char *buffer, size_t *currlen, size_t maxlen,
;1435:		   LLONG value, int base, int min, int max, int flags);
;1436:static int fmtfp (char *buffer, size_t *currlen, size_t maxlen,
;1437:		  LDOUBLE fvalue, int min, int max, int flags);
;1438:static int dopr_outch (char *buffer, size_t *currlen, size_t maxlen, char c );
;1439:
;1440:/*
;1441: * dopr(): poor man's version of doprintf
;1442: */
;1443:
;1444:/* format read states */
;1445:#define DP_S_DEFAULT 0
;1446:#define DP_S_FLAGS   1
;1447:#define DP_S_MIN     2
;1448:#define DP_S_DOT     3
;1449:#define DP_S_MAX     4
;1450:#define DP_S_MOD     5
;1451:#define DP_S_MOD_L   6
;1452:#define DP_S_CONV    7
;1453:#define DP_S_DONE    8
;1454:
;1455:/* format flags - Bits */
;1456:#define DP_F_MINUS 	(1 << 0)
;1457:#define DP_F_PLUS  	(1 << 1)
;1458:#define DP_F_SPACE 	(1 << 2)
;1459:#define DP_F_NUM   	(1 << 3)
;1460:#define DP_F_ZERO  	(1 << 4)
;1461:#define DP_F_UP    	(1 << 5)
;1462:#define DP_F_UNSIGNED 	(1 << 6)
;1463:
;1464:/* Conversion Flags */
;1465:#define DP_C_SHORT   1
;1466:#define DP_C_LONG    2
;1467:#define DP_C_LLONG   3
;1468:#define DP_C_LDOUBLE 4
;1469:
;1470:#define char_to_int(p) (p - '0')
;1471:#define MAX(p,q) ((p >= q) ? p : q)
;1472:#define MIN(p,q) ((p <= q) ? p : q)
;1473:
;1474:static int dopr (char *buffer, size_t maxlen, const char *format, va_list args)
;1475:{
line 1488
;1476:  char ch;
;1477:  LLONG value;
;1478:  LDOUBLE fvalue;
;1479:  char *strvalue;
;1480:  int min;
;1481:  int max;
;1482:  int state;
;1483:  int flags;
;1484:  int cflags;
;1485:  int total;
;1486:  size_t currlen;
;1487:  
;1488:  state = DP_S_DEFAULT;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1489
;1489:  currlen = flags = cflags = min = 0;
ADDRLP4 44
CNSTI4 0
ASGNI4
ADDRLP4 16
ADDRLP4 44
INDIRI4
ASGNI4
ADDRLP4 12
ADDRLP4 44
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 44
INDIRI4
ASGNI4
ADDRLP4 28
ADDRLP4 44
INDIRI4
ASGNI4
line 1490
;1490:  max = -1;
ADDRLP4 8
CNSTI4 -1
ASGNI4
line 1491
;1491:  ch = *format++;
ADDRLP4 48
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 48
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 48
INDIRP4
INDIRI1
ASGNI1
line 1492
;1492:  total = 0;
ADDRLP4 24
CNSTI4 0
ASGNI4
ADDRGP4 $455
JUMPV
LABELV $454
line 1495
;1493:
;1494:  while (state != DP_S_DONE)
;1495:  {
line 1496
;1496:    if (ch == '\0')
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $457
line 1497
;1497:      state = DP_S_DONE;
ADDRLP4 0
CNSTI4 8
ASGNI4
LABELV $457
line 1499
;1498:
;1499:    switch(state) 
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $460
ADDRLP4 0
INDIRI4
CNSTI4 8
GTI4 $460
ADDRLP4 0
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $567
ADDP4
INDIRP4
JUMPV
lit
align 4
LABELV $567
address $461
address $464
address $474
address $479
address $482
address $489
address $500
address $505
address $460
code
line 1500
;1500:    {
LABELV $461
line 1502
;1501:    case DP_S_DEFAULT:
;1502:      if (ch == '%') 
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 37
NEI4 $462
line 1503
;1503:	state = DP_S_FLAGS;
ADDRLP4 0
CNSTI4 1
ASGNI4
ADDRGP4 $463
JUMPV
LABELV $462
line 1505
;1504:      else 
;1505:	total += dopr_outch (buffer, &currlen, maxlen, ch);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 56
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 56
INDIRI4
ADDI4
ASGNI4
LABELV $463
line 1506
;1506:      ch = *format++;
ADDRLP4 60
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 60
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 60
INDIRP4
INDIRI1
ASGNI1
line 1507
;1507:      break;
ADDRGP4 $460
JUMPV
LABELV $464
line 1509
;1508:    case DP_S_FLAGS:
;1509:      switch (ch) 
ADDRLP4 64
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 72
CNSTI4 32
ASGNI4
ADDRLP4 64
INDIRI4
ADDRLP4 72
INDIRI4
EQI4 $470
ADDRLP4 64
INDIRI4
CNSTI4 35
EQI4 $471
ADDRLP4 64
INDIRI4
ADDRLP4 72
INDIRI4
LTI4 $465
LABELV $473
ADDRLP4 64
INDIRI4
CNSTI4 43
EQI4 $469
ADDRLP4 64
INDIRI4
CNSTI4 45
EQI4 $468
ADDRLP4 64
INDIRI4
CNSTI4 48
EQI4 $472
ADDRGP4 $465
JUMPV
line 1510
;1510:      {
LABELV $468
line 1512
;1511:      case '-':
;1512:	flags |= DP_F_MINUS;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 1
BORI4
ASGNI4
line 1513
;1513:        ch = *format++;
ADDRLP4 80
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 80
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 80
INDIRP4
INDIRI1
ASGNI1
line 1514
;1514:	break;
ADDRGP4 $460
JUMPV
LABELV $469
line 1516
;1515:      case '+':
;1516:	flags |= DP_F_PLUS;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 2
BORI4
ASGNI4
line 1517
;1517:        ch = *format++;
ADDRLP4 84
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 84
INDIRP4
INDIRI1
ASGNI1
line 1518
;1518:	break;
ADDRGP4 $460
JUMPV
LABELV $470
line 1520
;1519:      case ' ':
;1520:	flags |= DP_F_SPACE;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 4
BORI4
ASGNI4
line 1521
;1521:        ch = *format++;
ADDRLP4 88
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 88
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 88
INDIRP4
INDIRI1
ASGNI1
line 1522
;1522:	break;
ADDRGP4 $460
JUMPV
LABELV $471
line 1524
;1523:      case '#':
;1524:	flags |= DP_F_NUM;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 8
BORI4
ASGNI4
line 1525
;1525:        ch = *format++;
ADDRLP4 92
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 92
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 92
INDIRP4
INDIRI1
ASGNI1
line 1526
;1526:	break;
ADDRGP4 $460
JUMPV
LABELV $472
line 1528
;1527:      case '0':
;1528:	flags |= DP_F_ZERO;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 16
BORI4
ASGNI4
line 1529
;1529:        ch = *format++;
ADDRLP4 96
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 96
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 96
INDIRP4
INDIRI1
ASGNI1
line 1530
;1530:	break;
ADDRGP4 $460
JUMPV
LABELV $465
line 1532
;1531:      default:
;1532:	state = DP_S_MIN;
ADDRLP4 0
CNSTI4 2
ASGNI4
line 1533
;1533:	break;
line 1535
;1534:      }
;1535:      break;
ADDRGP4 $460
JUMPV
LABELV $474
line 1537
;1536:    case DP_S_MIN:
;1537:      if ('0' <= ch && ch <= '9')
ADDRLP4 80
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
CNSTI4 48
ADDRLP4 80
INDIRI4
GTI4 $475
ADDRLP4 80
INDIRI4
CNSTI4 57
GTI4 $475
line 1538
;1538:      {
line 1539
;1539:	min = 10*min + char_to_int (ch);
ADDRLP4 16
CNSTI4 10
ADDRLP4 16
INDIRI4
MULI4
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
ADDI4
ASGNI4
line 1540
;1540:	ch = *format++;
ADDRLP4 84
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 84
INDIRP4
INDIRI1
ASGNI1
line 1541
;1541:      } 
ADDRGP4 $460
JUMPV
LABELV $475
line 1542
;1542:      else if (ch == '*') 
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $477
line 1543
;1543:      {
line 1544
;1544:	min = va_arg (args, int);
ADDRLP4 84
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 84
INDIRP4
ASGNP4
ADDRLP4 16
ADDRLP4 84
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
line 1545
;1545:	ch = *format++;
ADDRLP4 88
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 88
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 88
INDIRP4
INDIRI1
ASGNI1
line 1546
;1546:	state = DP_S_DOT;
ADDRLP4 0
CNSTI4 3
ASGNI4
line 1547
;1547:      } 
ADDRGP4 $460
JUMPV
LABELV $477
line 1549
;1548:      else 
;1549:	state = DP_S_DOT;
ADDRLP4 0
CNSTI4 3
ASGNI4
line 1550
;1550:      break;
ADDRGP4 $460
JUMPV
LABELV $479
line 1552
;1551:    case DP_S_DOT:
;1552:      if (ch == '.') 
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 46
NEI4 $480
line 1553
;1553:      {
line 1554
;1554:	state = DP_S_MAX;
ADDRLP4 0
CNSTI4 4
ASGNI4
line 1555
;1555:	ch = *format++;
ADDRLP4 84
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 84
INDIRP4
INDIRI1
ASGNI1
line 1556
;1556:      } 
ADDRGP4 $460
JUMPV
LABELV $480
line 1558
;1557:      else 
;1558:	state = DP_S_MOD;
ADDRLP4 0
CNSTI4 5
ASGNI4
line 1559
;1559:      break;
ADDRGP4 $460
JUMPV
LABELV $482
line 1561
;1560:    case DP_S_MAX:
;1561:      if ('0' <= ch && ch <= '9')
ADDRLP4 84
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
CNSTI4 48
ADDRLP4 84
INDIRI4
GTI4 $483
ADDRLP4 84
INDIRI4
CNSTI4 57
GTI4 $483
line 1562
;1562:      {
line 1563
;1563:	if (max < 0)
ADDRLP4 8
INDIRI4
CNSTI4 0
GEI4 $485
line 1564
;1564:	  max = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
LABELV $485
line 1565
;1565:	max = 10*max + char_to_int (ch);
ADDRLP4 8
CNSTI4 10
ADDRLP4 8
INDIRI4
MULI4
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 48
SUBI4
ADDI4
ASGNI4
line 1566
;1566:	ch = *format++;
ADDRLP4 88
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 88
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 88
INDIRP4
INDIRI1
ASGNI1
line 1567
;1567:      } 
ADDRGP4 $460
JUMPV
LABELV $483
line 1568
;1568:      else if (ch == '*') 
ADDRLP4 4
INDIRI1
CVII4 1
CNSTI4 42
NEI4 $487
line 1569
;1569:      {
line 1570
;1570:	max = va_arg (args, int);
ADDRLP4 88
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 88
INDIRP4
ASGNP4
ADDRLP4 8
ADDRLP4 88
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
line 1571
;1571:	ch = *format++;
ADDRLP4 92
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 92
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 92
INDIRP4
INDIRI1
ASGNI1
line 1572
;1572:	state = DP_S_MOD;
ADDRLP4 0
CNSTI4 5
ASGNI4
line 1573
;1573:      } 
ADDRGP4 $460
JUMPV
LABELV $487
line 1575
;1574:      else 
;1575:	state = DP_S_MOD;
ADDRLP4 0
CNSTI4 5
ASGNI4
line 1576
;1576:      break;
ADDRGP4 $460
JUMPV
LABELV $489
line 1578
;1577:    case DP_S_MOD:
;1578:      switch (ch) 
ADDRLP4 88
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 96
CNSTI4 104
ASGNI4
ADDRLP4 88
INDIRI4
ADDRLP4 96
INDIRI4
EQI4 $493
ADDRLP4 88
INDIRI4
ADDRLP4 96
INDIRI4
GTI4 $497
LABELV $496
ADDRLP4 88
INDIRI4
CNSTI4 76
EQI4 $495
ADDRGP4 $491
JUMPV
LABELV $497
ADDRLP4 88
INDIRI4
CNSTI4 108
EQI4 $494
ADDRGP4 $491
JUMPV
line 1579
;1579:      {
LABELV $493
line 1581
;1580:      case 'h':
;1581:	cflags = DP_C_SHORT;
ADDRLP4 12
CNSTI4 1
ASGNI4
line 1582
;1582:	ch = *format++;
ADDRLP4 100
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 100
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 100
INDIRP4
INDIRI1
ASGNI1
line 1583
;1583:	break;
ADDRGP4 $491
JUMPV
LABELV $494
line 1585
;1584:      case 'l':
;1585:	cflags = DP_C_LONG;
ADDRLP4 12
CNSTI4 2
ASGNI4
line 1586
;1586:	ch = *format++;
ADDRLP4 104
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 104
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 104
INDIRP4
INDIRI1
ASGNI1
line 1587
;1587:	break;
ADDRGP4 $491
JUMPV
LABELV $495
line 1589
;1588:      case 'L':
;1589:	cflags = DP_C_LDOUBLE;
ADDRLP4 12
CNSTI4 4
ASGNI4
line 1590
;1590:	ch = *format++;
ADDRLP4 108
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 108
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 108
INDIRP4
INDIRI1
ASGNI1
line 1591
;1591:	break;
line 1593
;1592:      default:
;1593:	break;
LABELV $491
line 1595
;1594:      }
;1595:      if (cflags != DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
EQI4 $498
line 1596
;1596:	state = DP_S_CONV;
ADDRLP4 0
CNSTI4 7
ASGNI4
ADDRGP4 $460
JUMPV
LABELV $498
line 1598
;1597:      else
;1598:	state = DP_S_MOD_L;
ADDRLP4 0
CNSTI4 6
ASGNI4
line 1599
;1599:      break;
ADDRGP4 $460
JUMPV
LABELV $500
line 1601
;1600:    case DP_S_MOD_L:
;1601:      switch (ch)
ADDRLP4 100
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 100
INDIRI4
CNSTI4 108
EQI4 $504
ADDRGP4 $502
JUMPV
line 1602
;1602:	{
LABELV $504
line 1604
;1603:	case 'l':
;1604:	  cflags = DP_C_LLONG;
ADDRLP4 12
CNSTI4 3
ASGNI4
line 1605
;1605:	  ch = *format++;
ADDRLP4 104
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 104
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 104
INDIRP4
INDIRI1
ASGNI1
line 1606
;1606:	  break;
line 1608
;1607:	default:
;1608:	  break;
LABELV $502
line 1610
;1609:	}
;1610:      state = DP_S_CONV;
ADDRLP4 0
CNSTI4 7
ASGNI4
line 1611
;1611:      break;
ADDRGP4 $460
JUMPV
LABELV $505
line 1613
;1612:    case DP_S_CONV:
;1613:      switch (ch) 
ADDRLP4 104
ADDRLP4 4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 104
INDIRI4
CNSTI4 69
EQI4 $541
ADDRLP4 112
CNSTI4 71
ASGNI4
ADDRLP4 104
INDIRI4
ADDRLP4 112
INDIRI4
EQI4 $545
ADDRLP4 104
INDIRI4
ADDRLP4 112
INDIRI4
GTI4 $562
LABELV $561
ADDRLP4 104
INDIRI4
CNSTI4 37
EQI4 $559
ADDRGP4 $507
JUMPV
LABELV $562
ADDRLP4 120
CNSTI4 88
ASGNI4
ADDRLP4 104
INDIRI4
ADDRLP4 120
INDIRI4
EQI4 $530
ADDRLP4 104
INDIRI4
ADDRLP4 120
INDIRI4
LTI4 $507
LABELV $563
ADDRLP4 104
INDIRI4
CNSTI4 99
LTI4 $507
ADDRLP4 104
INDIRI4
CNSTI4 120
GTI4 $507
ADDRLP4 104
INDIRI4
CNSTI4 2
LSHI4
ADDRGP4 $564-396
ADDP4
INDIRP4
JUMPV
lit
align 4
LABELV $564
address $549
address $509
address $542
address $538
address $546
address $507
address $509
address $507
address $507
address $507
address $507
address $552
address $516
address $551
address $507
address $507
address $550
address $507
address $523
address $507
address $560
address $531
code
line 1614
;1614:      {
LABELV $509
line 1617
;1615:      case 'd':
;1616:      case 'i':
;1617:	if (cflags == DP_C_SHORT) 
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $510
line 1618
;1618:	  value = (short int)va_arg (args, int);
ADDRLP4 128
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 128
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 128
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
CVII2 4
CVII4 2
ASGNI4
ADDRGP4 $511
JUMPV
LABELV $510
line 1619
;1619:	else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $512
line 1620
;1620:	  value = va_arg (args, long int);
ADDRLP4 132
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 132
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 132
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $513
JUMPV
LABELV $512
line 1621
;1621:	else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $514
line 1622
;1622:	  value = va_arg (args, LLONG);
ADDRLP4 136
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 136
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 136
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
ADDRGP4 $515
JUMPV
LABELV $514
line 1624
;1623:	else
;1624:	  value = va_arg (args, int);
ADDRLP4 140
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 140
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 140
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
ASGNI4
LABELV $515
LABELV $513
LABELV $511
line 1625
;1625:	total += fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 10
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 144
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 144
INDIRI4
ADDI4
ASGNI4
line 1626
;1626:	break;
ADDRGP4 $507
JUMPV
LABELV $516
line 1628
;1627:      case 'o':
;1628:	flags |= DP_F_UNSIGNED;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 64
BORI4
ASGNI4
line 1629
;1629:	if (cflags == DP_C_SHORT)
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $517
line 1631
;1630://	  value = (unsigned short int) va_arg (args, unsigned short int); // Thilo: This does not work because the rcc compiler cannot do that cast correctly.
;1631:	  value = va_arg (args, unsigned int) & ( (1 << sizeof(unsigned short int) * 8) - 1); // Using this workaround instead.
ADDRLP4 148
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 148
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 148
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CNSTU4 65535
BANDU4
CVUI4 4
ASGNI4
ADDRGP4 $518
JUMPV
LABELV $517
line 1632
;1632:	else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $519
line 1633
;1633:	  value = va_arg (args, unsigned long int);
ADDRLP4 152
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 152
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 152
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $520
JUMPV
LABELV $519
line 1634
;1634:	else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $521
line 1635
;1635:	  value = va_arg (args, unsigned LLONG);
ADDRLP4 156
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 156
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 156
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $522
JUMPV
LABELV $521
line 1637
;1636:	else
;1637:	  value = va_arg (args, unsigned int);
ADDRLP4 160
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 160
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 160
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
LABELV $522
LABELV $520
LABELV $518
line 1638
;1638:	total += fmtint (buffer, &currlen, maxlen, value, 8, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 8
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 164
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 164
INDIRI4
ADDI4
ASGNI4
line 1639
;1639:	break;
ADDRGP4 $507
JUMPV
LABELV $523
line 1641
;1640:      case 'u':
;1641:	flags |= DP_F_UNSIGNED;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 64
BORI4
ASGNI4
line 1642
;1642:	if (cflags == DP_C_SHORT)
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $524
line 1643
;1643:	  value = va_arg (args, unsigned int) & ( (1 << sizeof(unsigned short int) * 8) - 1);
ADDRLP4 168
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 168
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 168
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CNSTU4 65535
BANDU4
CVUI4 4
ASGNI4
ADDRGP4 $525
JUMPV
LABELV $524
line 1644
;1644:	else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $526
line 1645
;1645:	  value = va_arg (args, unsigned long int);
ADDRLP4 172
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 172
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 172
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $527
JUMPV
LABELV $526
line 1646
;1646:	else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $528
line 1647
;1647:	  value = va_arg (args, unsigned LLONG);
ADDRLP4 176
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 176
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 176
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $529
JUMPV
LABELV $528
line 1649
;1648:	else
;1649:	  value = va_arg (args, unsigned int);
ADDRLP4 180
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 180
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 180
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
LABELV $529
LABELV $527
LABELV $525
line 1650
;1650:	total += fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 10
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 184
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 184
INDIRI4
ADDI4
ASGNI4
line 1651
;1651:	break;
ADDRGP4 $507
JUMPV
LABELV $530
line 1653
;1652:      case 'X':
;1653:	flags |= DP_F_UP;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 32
BORI4
ASGNI4
LABELV $531
line 1655
;1654:      case 'x':
;1655:	flags |= DP_F_UNSIGNED;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 64
BORI4
ASGNI4
line 1656
;1656:	if (cflags == DP_C_SHORT)
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $532
line 1657
;1657:	  value = va_arg (args, unsigned int) & ( (1 << sizeof(unsigned short int) * 8) - 1);
ADDRLP4 188
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 188
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 188
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CNSTU4 65535
BANDU4
CVUI4 4
ASGNI4
ADDRGP4 $533
JUMPV
LABELV $532
line 1658
;1658:	else if (cflags == DP_C_LONG)
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $534
line 1659
;1659:	  value = va_arg (args, unsigned long int);
ADDRLP4 192
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 192
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 192
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $535
JUMPV
LABELV $534
line 1660
;1660:	else if (cflags == DP_C_LLONG)
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $536
line 1661
;1661:	  value = va_arg (args, unsigned LLONG);
ADDRLP4 196
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 196
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 196
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
ADDRGP4 $537
JUMPV
LABELV $536
line 1663
;1662:	else
;1663:	  value = va_arg (args, unsigned int);
ADDRLP4 200
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 200
INDIRP4
ASGNP4
ADDRLP4 32
ADDRLP4 200
INDIRP4
CNSTI4 -4
ADDP4
INDIRU4
CVUI4 4
ASGNI4
LABELV $537
LABELV $535
LABELV $533
line 1664
;1664:	total += fmtint (buffer, &currlen, maxlen, value, 16, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 32
INDIRI4
ARGI4
CNSTI4 16
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 204
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 204
INDIRI4
ADDI4
ASGNI4
line 1665
;1665:	break;
ADDRGP4 $507
JUMPV
LABELV $538
line 1667
;1666:      case 'f':
;1667:	if (cflags == DP_C_LDOUBLE)
ADDRLP4 12
INDIRI4
CNSTI4 4
NEI4 $539
line 1668
;1668:	  fvalue = va_arg (args, LDOUBLE);
ADDRLP4 208
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 208
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 208
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
ADDRGP4 $540
JUMPV
LABELV $539
line 1670
;1669:	else
;1670:	  fvalue = va_arg (args, double);
ADDRLP4 212
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 212
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 212
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
LABELV $540
line 1672
;1671:	/* um, floating point? */
;1672:	total += fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 36
INDIRF4
ARGF4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 216
ADDRGP4 fmtfp
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 216
INDIRI4
ADDI4
ASGNI4
line 1673
;1673:	break;
ADDRGP4 $507
JUMPV
LABELV $541
line 1675
;1674:      case 'E':
;1675:	flags |= DP_F_UP;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 32
BORI4
ASGNI4
LABELV $542
line 1677
;1676:      case 'e':
;1677:	if (cflags == DP_C_LDOUBLE)
ADDRLP4 12
INDIRI4
CNSTI4 4
NEI4 $543
line 1678
;1678:	  fvalue = va_arg (args, LDOUBLE);
ADDRLP4 220
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 220
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 220
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
ADDRGP4 $544
JUMPV
LABELV $543
line 1680
;1679:	else
;1680:	  fvalue = va_arg (args, double);
ADDRLP4 224
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 224
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 224
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
LABELV $544
line 1682
;1681:	/* um, floating point? */
;1682:	total += fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 36
INDIRF4
ARGF4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 228
ADDRGP4 fmtfp
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 228
INDIRI4
ADDI4
ASGNI4
line 1683
;1683:	break;
ADDRGP4 $507
JUMPV
LABELV $545
line 1685
;1684:      case 'G':
;1685:	flags |= DP_F_UP;
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 32
BORI4
ASGNI4
LABELV $546
line 1687
;1686:      case 'g':
;1687:	if (cflags == DP_C_LDOUBLE)
ADDRLP4 12
INDIRI4
CNSTI4 4
NEI4 $547
line 1688
;1688:	  fvalue = va_arg (args, LDOUBLE);
ADDRLP4 232
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 232
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 232
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
ADDRGP4 $548
JUMPV
LABELV $547
line 1690
;1689:	else
;1690:	  fvalue = va_arg (args, double);
ADDRLP4 236
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 236
INDIRP4
ASGNP4
ADDRLP4 36
ADDRLP4 236
INDIRP4
CNSTI4 -4
ADDP4
INDIRF4
ASGNF4
LABELV $548
line 1692
;1691:	/* um, floating point? */
;1692:	total += fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 36
INDIRF4
ARGF4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 240
ADDRGP4 fmtfp
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 240
INDIRI4
ADDI4
ASGNI4
line 1693
;1693:	break;
ADDRGP4 $507
JUMPV
LABELV $549
line 1695
;1694:      case 'c':
;1695:	total += dopr_outch (buffer, &currlen, maxlen, va_arg (args, int));
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 244
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 244
INDIRP4
ASGNP4
ADDRLP4 244
INDIRP4
CNSTI4 -4
ADDP4
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 248
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 248
INDIRI4
ADDI4
ASGNI4
line 1696
;1696:	break;
ADDRGP4 $507
JUMPV
LABELV $550
line 1698
;1697:      case 's':
;1698:	strvalue = va_arg (args, char *);
ADDRLP4 252
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 252
INDIRP4
ASGNP4
ADDRLP4 40
ADDRLP4 252
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1699
;1699:	total += fmtstr (buffer, &currlen, maxlen, strvalue, flags, min, max);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 40
INDIRP4
ARGP4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 256
ADDRGP4 fmtstr
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 256
INDIRI4
ADDI4
ASGNI4
line 1700
;1700:	break;
ADDRGP4 $507
JUMPV
LABELV $551
line 1702
;1701:      case 'p':
;1702:	strvalue = va_arg (args, void *);
ADDRLP4 260
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 260
INDIRP4
ASGNP4
ADDRLP4 40
ADDRLP4 260
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1703
;1703:	total += fmtint (buffer, &currlen, maxlen, (long) strvalue, 16, min,
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 40
INDIRP4
CVPU4 4
CVUI4 4
ARGI4
CNSTI4 16
ARGI4
ADDRLP4 16
INDIRI4
ARGI4
ADDRLP4 8
INDIRI4
ARGI4
ADDRLP4 20
INDIRI4
ARGI4
ADDRLP4 264
ADDRGP4 fmtint
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 264
INDIRI4
ADDI4
ASGNI4
line 1705
;1704:                         max, flags);
;1705:	break;
ADDRGP4 $507
JUMPV
LABELV $552
line 1707
;1706:      case 'n':
;1707:	if (cflags == DP_C_SHORT) 
ADDRLP4 12
INDIRI4
CNSTI4 1
NEI4 $553
line 1708
;1708:	{
line 1710
;1709:	  short int *num;
;1710:	  num = va_arg (args, short int *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1711
;1711:	  *num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
CVII2 4
ASGNI2
line 1712
;1712:        }
ADDRGP4 $507
JUMPV
LABELV $553
line 1713
;1713:	else if (cflags == DP_C_LONG) 
ADDRLP4 12
INDIRI4
CNSTI4 2
NEI4 $555
line 1714
;1714:	{
line 1716
;1715:	  long int *num;
;1716:	  num = va_arg (args, long int *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1717
;1717:	  *num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
ASGNI4
line 1718
;1718:        } 
ADDRGP4 $507
JUMPV
LABELV $555
line 1719
;1719:	else if (cflags == DP_C_LLONG) 
ADDRLP4 12
INDIRI4
CNSTI4 3
NEI4 $557
line 1720
;1720:	{
line 1722
;1721:	  LLONG *num;
;1722:	  num = va_arg (args, LLONG *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1723
;1723:	  *num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
ASGNI4
line 1724
;1724:        } 
ADDRGP4 $507
JUMPV
LABELV $557
line 1726
;1725:	else 
;1726:	{
line 1728
;1727:	  int *num;
;1728:	  num = va_arg (args, int *);
ADDRLP4 272
ADDRFP4 12
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRFP4 12
ADDRLP4 272
INDIRP4
ASGNP4
ADDRLP4 268
ADDRLP4 272
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
line 1729
;1729:	  *num = currlen;
ADDRLP4 268
INDIRP4
ADDRLP4 28
INDIRI4
ASGNI4
line 1730
;1730:        }
line 1731
;1731:	break;
ADDRGP4 $507
JUMPV
LABELV $559
line 1733
;1732:      case '%':
;1733:	total += dopr_outch (buffer, &currlen, maxlen, ch);
ADDRFP4 0
INDIRP4
ARGP4
ADDRLP4 28
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRLP4 4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 268
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 24
ADDRLP4 24
INDIRI4
ADDRLP4 268
INDIRI4
ADDI4
ASGNI4
line 1734
;1734:	break;
ADDRGP4 $507
JUMPV
LABELV $560
line 1737
;1735:      case 'w':
;1736:	/* not supported yet, treat as next char */
;1737:	ch = *format++;
ADDRLP4 272
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 272
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 272
INDIRP4
INDIRI1
ASGNI1
line 1738
;1738:	break;
line 1741
;1739:      default:
;1740:	/* Unknown, skip */
;1741:	break;
LABELV $507
line 1743
;1742:      }
;1743:      ch = *format++;
ADDRLP4 128
ADDRFP4 8
INDIRP4
ASGNP4
ADDRFP4 8
ADDRLP4 128
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 4
ADDRLP4 128
INDIRP4
INDIRI1
ASGNI1
line 1744
;1744:      state = DP_S_DEFAULT;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1745
;1745:      flags = cflags = min = 0;
ADDRLP4 132
CNSTI4 0
ASGNI4
ADDRLP4 16
ADDRLP4 132
INDIRI4
ASGNI4
ADDRLP4 12
ADDRLP4 132
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 132
INDIRI4
ASGNI4
line 1746
;1746:      max = -1;
ADDRLP4 8
CNSTI4 -1
ASGNI4
line 1747
;1747:      break;
line 1749
;1748:    case DP_S_DONE:
;1749:      break;
line 1752
;1750:    default:
;1751:      /* hmm? */
;1752:      break; /* some picky compilers need this */
LABELV $460
line 1754
;1753:    }
;1754:  }
LABELV $455
line 1494
ADDRLP4 0
INDIRI4
CNSTI4 8
NEI4 $454
line 1755
;1755:  if (buffer != NULL)
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $568
line 1756
;1756:  {
line 1757
;1757:    if (currlen < maxlen - 1) 
ADDRLP4 28
INDIRI4
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
GEI4 $570
line 1758
;1758:      buffer[currlen] = '\0';
ADDRLP4 28
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
ADDRGP4 $571
JUMPV
LABELV $570
line 1760
;1759:    else 
;1760:      buffer[maxlen - 1] = '\0';
ADDRFP4 4
INDIRI4
CNSTI4 1
SUBI4
ADDRFP4 0
INDIRP4
ADDP4
CNSTI1 0
ASGNI1
LABELV $571
line 1761
;1761:  }
LABELV $568
line 1762
;1762:  return total;
ADDRLP4 24
INDIRI4
RETI4
LABELV $453
endproc dopr 276 32
proc fmtstr 32 16
line 1767
;1763:}
;1764:
;1765:static int fmtstr (char *buffer, size_t *currlen, size_t maxlen,
;1766:                   char *value, int flags, int min, int max)
;1767:{
line 1769
;1768:  int padlen, strln;     /* amount to pad */
;1769:  int cnt = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1770
;1770:  int total = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1772
;1771:  
;1772:  if (value == 0)
ADDRFP4 12
INDIRP4
CVPU4 4
CNSTU4 0
NEU4 $573
line 1773
;1773:  {
line 1774
;1774:    value = "<NULL>";
ADDRFP4 12
ADDRGP4 $575
ASGNP4
line 1775
;1775:  }
LABELV $573
line 1777
;1776:
;1777:  for (strln = 0; value[strln]; ++strln); /* strlen */
ADDRLP4 8
CNSTI4 0
ASGNI4
ADDRGP4 $579
JUMPV
LABELV $576
LABELV $577
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $579
ADDRLP4 8
INDIRI4
ADDRFP4 12
INDIRP4
ADDP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $576
line 1778
;1778:  if (max >= 0 && max < strln)
ADDRLP4 16
ADDRFP4 24
INDIRI4
ASGNI4
ADDRLP4 16
INDIRI4
CNSTI4 0
LTI4 $580
ADDRLP4 16
INDIRI4
ADDRLP4 8
INDIRI4
GEI4 $580
line 1779
;1779:    strln = max;
ADDRLP4 8
ADDRFP4 24
INDIRI4
ASGNI4
LABELV $580
line 1780
;1780:  padlen = min - strln;
ADDRLP4 0
ADDRFP4 20
INDIRI4
ADDRLP4 8
INDIRI4
SUBI4
ASGNI4
line 1781
;1781:  if (padlen < 0) 
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $582
line 1782
;1782:    padlen = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $582
line 1783
;1783:  if (flags & DP_F_MINUS) 
ADDRFP4 16
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $587
line 1784
;1784:    padlen = -padlen; /* Left Justify */
ADDRLP4 0
ADDRLP4 0
INDIRI4
NEGI4
ASGNI4
ADDRGP4 $587
JUMPV
LABELV $586
line 1787
;1785:
;1786:  while (padlen > 0)
;1787:  {
line 1788
;1788:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 20
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 20
INDIRI4
ADDI4
ASGNI4
line 1789
;1789:    --padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1790
;1790:  }
LABELV $587
line 1786
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $586
ADDRGP4 $590
JUMPV
LABELV $589
line 1792
;1791:  while (*value && ((max < 0) || (cnt < max)))
;1792:  {
line 1793
;1793:    total += dopr_outch (buffer, currlen, maxlen, *value++);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 20
ADDRFP4 12
INDIRP4
ASGNP4
ADDRFP4 12
ADDRLP4 20
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 20
INDIRP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 24
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 24
INDIRI4
ADDI4
ASGNI4
line 1794
;1794:    ++cnt;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1795
;1795:  }
LABELV $590
line 1791
ADDRLP4 20
CNSTI4 0
ASGNI4
ADDRFP4 12
INDIRP4
INDIRI1
CVII4 1
ADDRLP4 20
INDIRI4
EQI4 $592
ADDRLP4 24
ADDRFP4 24
INDIRI4
ASGNI4
ADDRLP4 24
INDIRI4
ADDRLP4 20
INDIRI4
LTI4 $589
ADDRLP4 12
INDIRI4
ADDRLP4 24
INDIRI4
LTI4 $589
LABELV $592
ADDRGP4 $594
JUMPV
LABELV $593
line 1797
;1796:  while (padlen < 0)
;1797:  {
line 1798
;1798:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 28
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 28
INDIRI4
ADDI4
ASGNI4
line 1799
;1799:    ++padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1800
;1800:  }
LABELV $594
line 1796
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $593
line 1801
;1801:  return total;
ADDRLP4 4
INDIRI4
RETI4
LABELV $572
endproc fmtstr 32 16
proc fmtint 76 16
line 1808
;1802:}
;1803:
;1804:/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
;1805:
;1806:static int fmtint (char *buffer, size_t *currlen, size_t maxlen,
;1807:		   LLONG value, int base, int min, int max, int flags)
;1808:{
line 1809
;1809:  int signvalue = 0;
ADDRLP4 48
CNSTI4 0
ASGNI4
line 1812
;1810:  unsigned LLONG uvalue;
;1811:  char convert[24];
;1812:  int place = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1813
;1813:  int spadlen = 0; /* amount to space pad */
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1814
;1814:  int zpadlen = 0; /* amount to zero pad */
ADDRLP4 40
CNSTI4 0
ASGNI4
line 1816
;1815:  const char *digits;
;1816:  int total = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
line 1818
;1817:  
;1818:  if (max < 0)
ADDRFP4 24
INDIRI4
CNSTI4 0
GEI4 $597
line 1819
;1819:    max = 0;
ADDRFP4 24
CNSTI4 0
ASGNI4
LABELV $597
line 1821
;1820:
;1821:  uvalue = value;
ADDRLP4 8
ADDRFP4 12
INDIRI4
CVIU4 4
ASGNU4
line 1823
;1822:
;1823:  if(!(flags & DP_F_UNSIGNED))
ADDRFP4 28
INDIRI4
CNSTI4 64
BANDI4
CNSTI4 0
NEI4 $599
line 1824
;1824:  {
line 1825
;1825:    if( value < 0 ) {
ADDRFP4 12
INDIRI4
CNSTI4 0
GEI4 $601
line 1826
;1826:      signvalue = '-';
ADDRLP4 48
CNSTI4 45
ASGNI4
line 1827
;1827:      uvalue = -value;
ADDRLP4 8
ADDRFP4 12
INDIRI4
NEGI4
CVIU4 4
ASGNU4
line 1828
;1828:    }
ADDRGP4 $602
JUMPV
LABELV $601
line 1830
;1829:    else
;1830:      if (flags & DP_F_PLUS)  /* Do a sign (+/i) */
ADDRFP4 28
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $603
line 1831
;1831:	signvalue = '+';
ADDRLP4 48
CNSTI4 43
ASGNI4
ADDRGP4 $604
JUMPV
LABELV $603
line 1833
;1832:    else
;1833:      if (flags & DP_F_SPACE)
ADDRFP4 28
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $605
line 1834
;1834:	signvalue = ' ';
ADDRLP4 48
CNSTI4 32
ASGNI4
LABELV $605
LABELV $604
LABELV $602
line 1835
;1835:  }
LABELV $599
line 1837
;1836:  
;1837:  if (flags & DP_F_UP)
ADDRFP4 28
INDIRI4
CNSTI4 32
BANDI4
CNSTI4 0
EQI4 $607
line 1839
;1838:    /* Should characters be upper case? */
;1839:    digits = "0123456789ABCDEF";
ADDRLP4 44
ADDRGP4 $609
ASGNP4
ADDRGP4 $608
JUMPV
LABELV $607
line 1841
;1840:  else
;1841:    digits = "0123456789abcdef";
ADDRLP4 44
ADDRGP4 $610
ASGNP4
LABELV $608
LABELV $611
line 1843
;1842:
;1843:  do {
line 1844
;1844:    convert[place++] = digits[uvalue % (unsigned)base];
ADDRLP4 52
ADDRLP4 0
INDIRI4
ASGNI4
ADDRLP4 0
ADDRLP4 52
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 52
INDIRI4
ADDRLP4 16
ADDP4
ADDRLP4 8
INDIRU4
ADDRFP4 16
INDIRI4
CVIU4 4
MODU4
ADDRLP4 44
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 1845
;1845:    uvalue = (uvalue / (unsigned)base );
ADDRLP4 8
ADDRLP4 8
INDIRU4
ADDRFP4 16
INDIRI4
CVIU4 4
DIVU4
ASGNU4
line 1846
;1846:  } while(uvalue && (place < sizeof (convert)));
LABELV $612
ADDRLP4 8
INDIRU4
CNSTU4 0
EQU4 $614
ADDRLP4 0
INDIRI4
CVIU4 4
CNSTU4 24
LTU4 $611
LABELV $614
line 1847
;1847:  if (place == sizeof (convert)) place--;
ADDRLP4 0
INDIRI4
CVIU4 4
CNSTU4 24
NEU4 $615
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $615
line 1848
;1848:  convert[place] = 0;
ADDRLP4 0
INDIRI4
ADDRLP4 16
ADDP4
CNSTI1 0
ASGNI1
line 1850
;1849:
;1850:  zpadlen = max - place;
ADDRLP4 40
ADDRFP4 24
INDIRI4
ADDRLP4 0
INDIRI4
SUBI4
ASGNI4
line 1851
;1851:  spadlen = min - MAX (max, place) - (signvalue ? 1 : 0);
ADDRFP4 24
INDIRI4
ADDRLP4 0
INDIRI4
LTI4 $619
ADDRLP4 52
ADDRFP4 24
INDIRI4
ASGNI4
ADDRGP4 $620
JUMPV
LABELV $619
ADDRLP4 52
ADDRLP4 0
INDIRI4
ASGNI4
LABELV $620
ADDRLP4 48
INDIRI4
CNSTI4 0
EQI4 $621
ADDRLP4 56
CNSTI4 1
ASGNI4
ADDRGP4 $622
JUMPV
LABELV $621
ADDRLP4 56
CNSTI4 0
ASGNI4
LABELV $622
ADDRLP4 4
ADDRFP4 20
INDIRI4
ADDRLP4 52
INDIRI4
SUBI4
ADDRLP4 56
INDIRI4
SUBI4
ASGNI4
line 1852
;1852:  if (zpadlen < 0) zpadlen = 0;
ADDRLP4 40
INDIRI4
CNSTI4 0
GEI4 $623
ADDRLP4 40
CNSTI4 0
ASGNI4
LABELV $623
line 1853
;1853:  if (spadlen < 0) spadlen = 0;
ADDRLP4 4
INDIRI4
CNSTI4 0
GEI4 $625
ADDRLP4 4
CNSTI4 0
ASGNI4
LABELV $625
line 1854
;1854:  if (flags & DP_F_ZERO)
ADDRFP4 28
INDIRI4
CNSTI4 16
BANDI4
CNSTI4 0
EQI4 $627
line 1855
;1855:  {
line 1856
;1856:    zpadlen = MAX(zpadlen, spadlen);
ADDRLP4 40
INDIRI4
ADDRLP4 4
INDIRI4
LTI4 $630
ADDRLP4 60
ADDRLP4 40
INDIRI4
ASGNI4
ADDRGP4 $631
JUMPV
LABELV $630
ADDRLP4 60
ADDRLP4 4
INDIRI4
ASGNI4
LABELV $631
ADDRLP4 40
ADDRLP4 60
INDIRI4
ASGNI4
line 1857
;1857:    spadlen = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1858
;1858:  }
LABELV $627
line 1859
;1859:  if (flags & DP_F_MINUS) 
ADDRFP4 28
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $635
line 1860
;1860:    spadlen = -spadlen; /* Left Justifty */
ADDRLP4 4
ADDRLP4 4
INDIRI4
NEGI4
ASGNI4
ADDRGP4 $635
JUMPV
LABELV $634
line 1869
;1861:
;1862:#ifdef DEBUG_SNPRINTF
;1863:  dprint (1, (debugfile, "zpad: %d, spad: %d, min: %d, max: %d, place: %d\n",
;1864:      zpadlen, spadlen, min, max, place));
;1865:#endif
;1866:
;1867:  /* Spaces */
;1868:  while (spadlen > 0) 
;1869:  {
line 1870
;1870:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 60
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 60
INDIRI4
ADDI4
ASGNI4
line 1871
;1871:    --spadlen;
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1872
;1872:  }
LABELV $635
line 1868
ADDRLP4 4
INDIRI4
CNSTI4 0
GTI4 $634
line 1875
;1873:
;1874:  /* Sign */
;1875:  if (signvalue) 
ADDRLP4 48
INDIRI4
CNSTI4 0
EQI4 $637
line 1876
;1876:    total += dopr_outch (buffer, currlen, maxlen, signvalue);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 48
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 60
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 60
INDIRI4
ADDI4
ASGNI4
LABELV $637
line 1879
;1877:
;1878:  /* Zeros */
;1879:  if (zpadlen > 0) 
ADDRLP4 40
INDIRI4
CNSTI4 0
LEI4 $645
line 1880
;1880:  {
ADDRGP4 $642
JUMPV
LABELV $641
line 1882
;1881:    while (zpadlen > 0)
;1882:    {
line 1883
;1883:      total += dopr_outch (buffer, currlen, maxlen, '0');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 48
ARGI4
ADDRLP4 64
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 64
INDIRI4
ADDI4
ASGNI4
line 1884
;1884:      --zpadlen;
ADDRLP4 40
ADDRLP4 40
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1885
;1885:    }
LABELV $642
line 1881
ADDRLP4 40
INDIRI4
CNSTI4 0
GTI4 $641
line 1886
;1886:  }
ADDRGP4 $645
JUMPV
LABELV $644
line 1890
;1887:
;1888:  /* Digits */
;1889:  while (place > 0) 
;1890:    total += dopr_outch (buffer, currlen, maxlen, convert[--place]);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 64
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 0
ADDRLP4 64
INDIRI4
ASGNI4
ADDRLP4 64
INDIRI4
ADDRLP4 16
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 68
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 68
INDIRI4
ADDI4
ASGNI4
LABELV $645
line 1889
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $644
ADDRGP4 $648
JUMPV
LABELV $647
line 1893
;1891:  
;1892:  /* Left Justified spaces */
;1893:  while (spadlen < 0) {
line 1894
;1894:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 72
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 12
ADDRLP4 12
INDIRI4
ADDRLP4 72
INDIRI4
ADDI4
ASGNI4
line 1895
;1895:    ++spadlen;
ADDRLP4 4
ADDRLP4 4
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1896
;1896:  }
LABELV $648
line 1893
ADDRLP4 4
INDIRI4
CNSTI4 0
LTI4 $647
line 1898
;1897:
;1898:  return total;
ADDRLP4 12
INDIRI4
RETI4
LABELV $596
endproc fmtint 76 16
proc abs_val 4 0
line 1902
;1899:}
;1900:
;1901:static LDOUBLE abs_val (LDOUBLE value)
;1902:{
line 1903
;1903:  LDOUBLE result = value;
ADDRLP4 0
ADDRFP4 0
INDIRF4
ASGNF4
line 1905
;1904:
;1905:  if (value < 0)
ADDRFP4 0
INDIRF4
CNSTF4 0
GEF4 $651
line 1906
;1906:    result = -value;
ADDRLP4 0
ADDRFP4 0
INDIRF4
NEGF4
ASGNF4
LABELV $651
line 1908
;1907:
;1908:  return result;
ADDRLP4 0
INDIRF4
RETF4
LABELV $650
endproc abs_val 4 0
proc pow10 4 0
line 1912
;1909:}
;1910:
;1911:static LDOUBLE pow10 (int exp)
;1912:{
line 1913
;1913:  LDOUBLE result = 1;
ADDRLP4 0
CNSTF4 1065353216
ASGNF4
ADDRGP4 $655
JUMPV
LABELV $654
line 1916
;1914:
;1915:  while (exp)
;1916:  {
line 1917
;1917:    result *= 10;
ADDRLP4 0
CNSTF4 1092616192
ADDRLP4 0
INDIRF4
MULF4
ASGNF4
line 1918
;1918:    exp--;
ADDRFP4 0
ADDRFP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 1919
;1919:  }
LABELV $655
line 1915
ADDRFP4 0
INDIRI4
CNSTI4 0
NEI4 $654
line 1921
;1920:  
;1921:  return result;
ADDRLP4 0
INDIRF4
RETF4
LABELV $653
endproc pow10 4 0
proc round 4 0
line 1925
;1922:}
;1923:
;1924:static long round (LDOUBLE value)
;1925:{
line 1928
;1926:  long intpart;
;1927:
;1928:  intpart = value;
ADDRLP4 0
ADDRFP4 0
INDIRF4
CVFI4 4
ASGNI4
line 1929
;1929:  value = value - intpart;
ADDRFP4 0
ADDRFP4 0
INDIRF4
ADDRLP4 0
INDIRI4
CVIF4 4
SUBF4
ASGNF4
line 1930
;1930:  if (value >= 0.5)
ADDRFP4 0
INDIRF4
CNSTF4 1056964608
LTF4 $658
line 1931
;1931:    intpart++;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
LABELV $658
line 1933
;1932:
;1933:  return intpart;
ADDRLP4 0
INDIRI4
RETI4
LABELV $657
endproc round 4 0
proc fmtfp 136 16
line 1938
;1934:}
;1935:
;1936:static int fmtfp (char *buffer, size_t *currlen, size_t maxlen,
;1937:		  LDOUBLE fvalue, int min, int max, int flags)
;1938:{
line 1939
;1939:  int signvalue = 0;
ADDRLP4 72
CNSTI4 0
ASGNI4
line 1943
;1940:  LDOUBLE ufvalue;
;1941:  char iconvert[20];
;1942:  char fconvert[20];
;1943:  int iplace = 0;
ADDRLP4 8
CNSTI4 0
ASGNI4
line 1944
;1944:  int fplace = 0;
ADDRLP4 20
CNSTI4 0
ASGNI4
line 1945
;1945:  int padlen = 0; /* amount to pad */
ADDRLP4 0
CNSTI4 0
ASGNI4
line 1946
;1946:  int zpadlen = 0; 
ADDRLP4 68
CNSTI4 0
ASGNI4
line 1947
;1947:  int caps = 0;
ADDRLP4 44
CNSTI4 0
ASGNI4
line 1948
;1948:  int total = 0;
ADDRLP4 4
CNSTI4 0
ASGNI4
line 1956
;1949:  long intpart;
;1950:  long fracpart;
;1951:  
;1952:  /* 
;1953:   * AIX manpage says the default is 0, but Solaris says the default
;1954:   * is 6, and sprintf on AIX defaults to 6
;1955:   */
;1956:  if (max < 0)
ADDRFP4 20
INDIRI4
CNSTI4 0
GEI4 $661
line 1957
;1957:    max = 6;
ADDRFP4 20
CNSTI4 6
ASGNI4
LABELV $661
line 1959
;1958:
;1959:  ufvalue = abs_val (fvalue);
ADDRFP4 12
INDIRF4
ARGF4
ADDRLP4 80
ADDRGP4 abs_val
CALLF4
ASGNF4
ADDRLP4 76
ADDRLP4 80
INDIRF4
ASGNF4
line 1961
;1960:
;1961:  if (fvalue < 0)
ADDRFP4 12
INDIRF4
CNSTF4 0
GEF4 $663
line 1962
;1962:    signvalue = '-';
ADDRLP4 72
CNSTI4 45
ASGNI4
ADDRGP4 $664
JUMPV
LABELV $663
line 1964
;1963:  else
;1964:    if (flags & DP_F_PLUS)  /* Do a sign (+/i) */
ADDRFP4 24
INDIRI4
CNSTI4 2
BANDI4
CNSTI4 0
EQI4 $665
line 1965
;1965:      signvalue = '+';
ADDRLP4 72
CNSTI4 43
ASGNI4
ADDRGP4 $666
JUMPV
LABELV $665
line 1967
;1966:    else
;1967:      if (flags & DP_F_SPACE)
ADDRFP4 24
INDIRI4
CNSTI4 4
BANDI4
CNSTI4 0
EQI4 $667
line 1968
;1968:	signvalue = ' ';
ADDRLP4 72
CNSTI4 32
ASGNI4
LABELV $667
LABELV $666
LABELV $664
line 1974
;1969:
;1970:#if 0
;1971:  if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */
;1972:#endif
;1973:
;1974:  intpart = ufvalue;
ADDRLP4 12
ADDRLP4 76
INDIRF4
CVFI4 4
ASGNI4
line 1980
;1975:
;1976:  /* 
;1977:   * Sorry, we only support 9 digits past the decimal because of our 
;1978:   * conversion method
;1979:   */
;1980:  if (max > 9)
ADDRFP4 20
INDIRI4
CNSTI4 9
LEI4 $669
line 1981
;1981:    max = 9;
ADDRFP4 20
CNSTI4 9
ASGNI4
LABELV $669
line 1986
;1982:
;1983:  /* We "cheat" by converting the fractional part to integer by
;1984:   * multiplying by a factor of 10
;1985:   */
;1986:  fracpart = round ((pow10 (max)) * (ufvalue - intpart));
ADDRFP4 20
INDIRI4
ARGI4
ADDRLP4 84
ADDRGP4 pow10
CALLF4
ASGNF4
ADDRLP4 84
INDIRF4
ADDRLP4 76
INDIRF4
ADDRLP4 12
INDIRI4
CVIF4 4
SUBF4
MULF4
ARGF4
ADDRLP4 88
ADDRGP4 round
CALLI4
ASGNI4
ADDRLP4 16
ADDRLP4 88
INDIRI4
ASGNI4
line 1988
;1987:
;1988:  if (fracpart >= pow10 (max))
ADDRFP4 20
INDIRI4
ARGI4
ADDRLP4 92
ADDRGP4 pow10
CALLF4
ASGNF4
ADDRLP4 16
INDIRI4
CVIF4 4
ADDRLP4 92
INDIRF4
LTF4 $671
line 1989
;1989:  {
line 1990
;1990:    intpart++;
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 1991
;1991:    fracpart -= pow10 (max);
ADDRFP4 20
INDIRI4
ARGI4
ADDRLP4 96
ADDRGP4 pow10
CALLF4
ASGNF4
ADDRLP4 16
ADDRLP4 16
INDIRI4
CVIF4 4
ADDRLP4 96
INDIRF4
SUBF4
CVFI4 4
ASGNI4
line 1992
;1992:  }
LABELV $671
LABELV $673
line 1999
;1993:
;1994:#ifdef DEBUG_SNPRINTF
;1995:  dprint (1, (debugfile, "fmtfp: %f =? %d.%d\n", fvalue, intpart, fracpart));
;1996:#endif
;1997:
;1998:  /* Convert integer part */
;1999:  do {
line 2000
;2000:    iconvert[iplace++] =
ADDRLP4 100
ADDRLP4 8
INDIRI4
ASGNI4
ADDRLP4 8
ADDRLP4 100
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
EQI4 $677
ADDRLP4 96
ADDRGP4 $609
ASGNP4
ADDRGP4 $678
JUMPV
LABELV $677
ADDRLP4 96
ADDRGP4 $610
ASGNP4
LABELV $678
ADDRLP4 100
INDIRI4
ADDRLP4 24
ADDP4
ADDRLP4 12
INDIRI4
CNSTI4 10
MODI4
ADDRLP4 96
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 2002
;2001:      (caps? "0123456789ABCDEF":"0123456789abcdef")[intpart % 10];
;2002:    intpart = (intpart / 10);
ADDRLP4 12
ADDRLP4 12
INDIRI4
CNSTI4 10
DIVI4
ASGNI4
line 2003
;2003:  } while(intpart && (iplace < 20));
LABELV $674
ADDRLP4 12
INDIRI4
CNSTI4 0
EQI4 $679
ADDRLP4 8
INDIRI4
CNSTI4 20
LTI4 $673
LABELV $679
line 2004
;2004:  if (iplace == 20) iplace--;
ADDRLP4 8
INDIRI4
CNSTI4 20
NEI4 $680
ADDRLP4 8
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $680
line 2005
;2005:  iconvert[iplace] = 0;
ADDRLP4 8
INDIRI4
ADDRLP4 24
ADDP4
CNSTI1 0
ASGNI1
LABELV $682
line 2008
;2006:
;2007:  /* Convert fractional part */
;2008:  do {
line 2009
;2009:    fconvert[fplace++] =
ADDRLP4 100
ADDRLP4 20
INDIRI4
ASGNI4
ADDRLP4 20
ADDRLP4 100
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 44
INDIRI4
CNSTI4 0
EQI4 $686
ADDRLP4 96
ADDRGP4 $609
ASGNP4
ADDRGP4 $687
JUMPV
LABELV $686
ADDRLP4 96
ADDRGP4 $610
ASGNP4
LABELV $687
ADDRLP4 100
INDIRI4
ADDRLP4 48
ADDP4
ADDRLP4 16
INDIRI4
CNSTI4 10
MODI4
ADDRLP4 96
INDIRP4
ADDP4
INDIRI1
ASGNI1
line 2011
;2010:      (caps? "0123456789ABCDEF":"0123456789abcdef")[fracpart % 10];
;2011:    fracpart = (fracpart / 10);
ADDRLP4 16
ADDRLP4 16
INDIRI4
CNSTI4 10
DIVI4
ASGNI4
line 2012
;2012:  } while(fracpart && (fplace < 20));
LABELV $683
ADDRLP4 16
INDIRI4
CNSTI4 0
EQI4 $688
ADDRLP4 20
INDIRI4
CNSTI4 20
LTI4 $682
LABELV $688
line 2013
;2013:  if (fplace == 20) fplace--;
ADDRLP4 20
INDIRI4
CNSTI4 20
NEI4 $689
ADDRLP4 20
ADDRLP4 20
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
LABELV $689
line 2014
;2014:  fconvert[fplace] = 0;
ADDRLP4 20
INDIRI4
ADDRLP4 48
ADDP4
CNSTI1 0
ASGNI1
line 2017
;2015:
;2016:  /* -1 for decimal point, another -1 if we are printing a sign */
;2017:  padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0); 
ADDRLP4 72
INDIRI4
CNSTI4 0
EQI4 $692
ADDRLP4 96
CNSTI4 1
ASGNI4
ADDRGP4 $693
JUMPV
LABELV $692
ADDRLP4 96
CNSTI4 0
ASGNI4
LABELV $693
ADDRLP4 0
ADDRFP4 16
INDIRI4
ADDRLP4 8
INDIRI4
SUBI4
ADDRFP4 20
INDIRI4
SUBI4
CNSTI4 1
SUBI4
ADDRLP4 96
INDIRI4
SUBI4
ASGNI4
line 2018
;2018:  zpadlen = max - fplace;
ADDRLP4 68
ADDRFP4 20
INDIRI4
ADDRLP4 20
INDIRI4
SUBI4
ASGNI4
line 2019
;2019:  if (zpadlen < 0)
ADDRLP4 68
INDIRI4
CNSTI4 0
GEI4 $694
line 2020
;2020:    zpadlen = 0;
ADDRLP4 68
CNSTI4 0
ASGNI4
LABELV $694
line 2021
;2021:  if (padlen < 0) 
ADDRLP4 0
INDIRI4
CNSTI4 0
GEI4 $696
line 2022
;2022:    padlen = 0;
ADDRLP4 0
CNSTI4 0
ASGNI4
LABELV $696
line 2023
;2023:  if (flags & DP_F_MINUS) 
ADDRFP4 24
INDIRI4
CNSTI4 1
BANDI4
CNSTI4 0
EQI4 $698
line 2024
;2024:    padlen = -padlen; /* Left Justifty */
ADDRLP4 0
ADDRLP4 0
INDIRI4
NEGI4
ASGNI4
LABELV $698
line 2026
;2025:
;2026:  if ((flags & DP_F_ZERO) && (padlen > 0)) 
ADDRLP4 100
CNSTI4 0
ASGNI4
ADDRFP4 24
INDIRI4
CNSTI4 16
BANDI4
ADDRLP4 100
INDIRI4
EQI4 $708
ADDRLP4 0
INDIRI4
ADDRLP4 100
INDIRI4
LEI4 $708
line 2027
;2027:  {
line 2028
;2028:    if (signvalue) 
ADDRLP4 72
INDIRI4
CNSTI4 0
EQI4 $705
line 2029
;2029:    {
line 2030
;2030:      total += dopr_outch (buffer, currlen, maxlen, signvalue);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 72
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
line 2031
;2031:      --padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 2032
;2032:      signvalue = 0;
ADDRLP4 72
CNSTI4 0
ASGNI4
line 2033
;2033:    }
ADDRGP4 $705
JUMPV
LABELV $704
line 2035
;2034:    while (padlen > 0)
;2035:    {
line 2036
;2036:      total += dopr_outch (buffer, currlen, maxlen, '0');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 48
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
line 2037
;2037:      --padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 2038
;2038:    }
LABELV $705
line 2034
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $704
line 2039
;2039:  }
ADDRGP4 $708
JUMPV
LABELV $707
line 2041
;2040:  while (padlen > 0)
;2041:  {
line 2042
;2042:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
line 2043
;2043:    --padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
line 2044
;2044:  }
LABELV $708
line 2040
ADDRLP4 0
INDIRI4
CNSTI4 0
GTI4 $707
line 2045
;2045:  if (signvalue) 
ADDRLP4 72
INDIRI4
CNSTI4 0
EQI4 $713
line 2046
;2046:    total += dopr_outch (buffer, currlen, maxlen, signvalue);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 72
INDIRI4
CVII1 4
CVII4 1
ARGI4
ADDRLP4 104
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 104
INDIRI4
ADDI4
ASGNI4
ADDRGP4 $713
JUMPV
LABELV $712
line 2049
;2047:
;2048:  while (iplace > 0) 
;2049:    total += dopr_outch (buffer, currlen, maxlen, iconvert[--iplace]);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 108
ADDRLP4 8
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 8
ADDRLP4 108
INDIRI4
ASGNI4
ADDRLP4 108
INDIRI4
ADDRLP4 24
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 112
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 112
INDIRI4
ADDI4
ASGNI4
LABELV $713
line 2048
ADDRLP4 8
INDIRI4
CNSTI4 0
GTI4 $712
line 2055
;2050:
;2051:  /*
;2052:   * Decimal point.  This should probably use locale to find the correct
;2053:   * char to print out.
;2054:   */
;2055:  if (max > 0)
ADDRFP4 20
INDIRI4
CNSTI4 0
LEI4 $724
line 2056
;2056:  {
line 2057
;2057:    total += dopr_outch (buffer, currlen, maxlen, '.');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 46
ARGI4
ADDRLP4 116
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 116
INDIRI4
ADDI4
ASGNI4
ADDRGP4 $718
JUMPV
LABELV $717
line 2060
;2058:
;2059:    while (zpadlen-- > 0)
;2060:      total += dopr_outch (buffer, currlen, maxlen, '0');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 48
ARGI4
ADDRLP4 120
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 120
INDIRI4
ADDI4
ASGNI4
LABELV $718
line 2059
ADDRLP4 124
ADDRLP4 68
INDIRI4
ASGNI4
ADDRLP4 68
ADDRLP4 124
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 124
INDIRI4
CNSTI4 0
GTI4 $717
ADDRGP4 $721
JUMPV
LABELV $720
line 2063
;2061:
;2062:    while (fplace > 0) 
;2063:      total += dopr_outch (buffer, currlen, maxlen, fconvert[--fplace]);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
ADDRLP4 128
ADDRLP4 20
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 20
ADDRLP4 128
INDIRI4
ASGNI4
ADDRLP4 128
INDIRI4
ADDRLP4 48
ADDP4
INDIRI1
CVII4 1
ARGI4
ADDRLP4 132
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 132
INDIRI4
ADDI4
ASGNI4
LABELV $721
line 2062
ADDRLP4 20
INDIRI4
CNSTI4 0
GTI4 $720
line 2064
;2064:  }
ADDRGP4 $724
JUMPV
LABELV $723
line 2067
;2065:
;2066:  while (padlen < 0) 
;2067:  {
line 2068
;2068:    total += dopr_outch (buffer, currlen, maxlen, ' ');
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRP4
ARGP4
ADDRFP4 8
INDIRI4
ARGI4
CNSTI4 32
ARGI4
ADDRLP4 116
ADDRGP4 dopr_outch
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 4
INDIRI4
ADDRLP4 116
INDIRI4
ADDI4
ASGNI4
line 2069
;2069:    ++padlen;
ADDRLP4 0
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
line 2070
;2070:  }
LABELV $724
line 2066
ADDRLP4 0
INDIRI4
CNSTI4 0
LTI4 $723
line 2072
;2071:
;2072:  return total;
ADDRLP4 4
INDIRI4
RETI4
LABELV $660
endproc fmtfp 136 16
proc dopr_outch 8 0
ADDRFP4 12
ADDRFP4 12
INDIRI4
CVII1 4
ASGNI1
line 2076
;2073:}
;2074:
;2075:static int dopr_outch (char *buffer, size_t *currlen, size_t maxlen, char c)
;2076:{
line 2077
;2077:  if (*currlen + 1 < maxlen)
ADDRFP4 4
INDIRP4
INDIRI4
CNSTI4 1
ADDI4
ADDRFP4 8
INDIRI4
GEI4 $727
line 2078
;2078:    buffer[(*currlen)++] = c;
ADDRLP4 4
ADDRFP4 4
INDIRP4
ASGNP4
ADDRLP4 0
ADDRLP4 4
INDIRP4
INDIRI4
ASGNI4
ADDRLP4 4
INDIRP4
ADDRLP4 0
INDIRI4
CNSTI4 1
ADDI4
ASGNI4
ADDRLP4 0
INDIRI4
ADDRFP4 0
INDIRP4
ADDP4
ADDRFP4 12
INDIRI1
ASGNI1
LABELV $727
line 2079
;2079:  return 1;
CNSTI4 1
RETI4
LABELV $726
endproc dopr_outch 8 0
export Q_vsnprintf
proc Q_vsnprintf 4 16
line 2083
;2080:}
;2081:
;2082:int Q_vsnprintf(char *str, size_t length, const char *fmt, va_list args)
;2083:{
line 2084
;2084:	if (str != NULL)
ADDRFP4 0
INDIRP4
CVPU4 4
CNSTU4 0
EQU4 $730
line 2085
;2085:		str[0] = 0;
ADDRFP4 0
INDIRP4
CNSTI1 0
ASGNI1
LABELV $730
line 2086
;2086:	return dopr(str, length, fmt, args);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRFP4 12
INDIRP4
ARGP4
ADDRLP4 0
ADDRGP4 dopr
CALLI4
ASGNI4
ADDRLP4 0
INDIRI4
RETI4
LABELV $729
endproc Q_vsnprintf 4 16
export Q_snprintf
proc Q_snprintf 12 16
line 2090
;2087:}
;2088:
;2089:int Q_snprintf(char *str, size_t length, const char *fmt, ...)
;2090:{
line 2094
;2091:	va_list ap;
;2092:	int retval;
;2093:
;2094:	va_start(ap, fmt);
ADDRLP4 0
ADDRFP4 8+4
ASGNP4
line 2095
;2095:	retval = Q_vsnprintf(str, length, fmt, ap);
ADDRFP4 0
INDIRP4
ARGP4
ADDRFP4 4
INDIRI4
ARGI4
ADDRFP4 8
INDIRP4
ARGP4
ADDRLP4 0
INDIRP4
ARGP4
ADDRLP4 8
ADDRGP4 Q_vsnprintf
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 8
INDIRI4
ASGNI4
line 2096
;2096:	va_end(ap);
ADDRLP4 0
CNSTP4 0
ASGNP4
line 2098
;2097:	
;2098:	return retval;
ADDRLP4 4
INDIRI4
RETI4
LABELV $732
endproc Q_snprintf 12 16
export sscanf
proc sscanf 88 4
line 2102
;2099:}
;2100:
;2101:/* this is really crappy */
;2102:int sscanf( const char *buffer, const char *fmt, ... ) {
line 2108
;2103:	int		cmd;
;2104:	va_list		ap;
;2105:	int		count;
;2106:	size_t		len;
;2107:
;2108:	va_start (ap, fmt);
ADDRLP4 8
ADDRFP4 4+4
ASGNP4
line 2109
;2109:	count = 0;
ADDRLP4 12
CNSTI4 0
ASGNI4
ADDRGP4 $737
JUMPV
LABELV $736
line 2111
;2110:
;2111:	while ( *fmt ) {
line 2112
;2112:		if ( fmt[0] != '%' ) {
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 37
EQI4 $739
line 2113
;2113:			fmt++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2114
;2114:			continue;
ADDRGP4 $737
JUMPV
LABELV $739
line 2117
;2115:		}
;2116:
;2117:		fmt++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2118
;2118:		cmd = *fmt;
ADDRLP4 0
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
ASGNI4
line 2120
;2119:
;2120:		if (isdigit (cmd)) {
ADDRLP4 0
INDIRI4
CNSTI4 48
LTI4 $741
ADDRLP4 0
INDIRI4
CNSTI4 57
GTI4 $741
line 2121
;2121:			len = (size_t)_atoi (&fmt);
ADDRFP4 4
ARGP4
ADDRLP4 20
ADDRGP4 _atoi
CALLI4
ASGNI4
ADDRLP4 4
ADDRLP4 20
INDIRI4
ASGNI4
line 2122
;2122:			cmd = *(fmt - 1);
ADDRLP4 0
ADDRFP4 4
INDIRP4
CNSTI4 -1
ADDP4
INDIRI1
CVII4 1
ASGNI4
line 2123
;2123:		} else {
ADDRGP4 $742
JUMPV
LABELV $741
line 2124
;2124:			len = MAX_STRING_CHARS - 1;
ADDRLP4 4
CNSTI4 1023
ASGNI4
line 2125
;2125:			fmt++;
ADDRFP4 4
ADDRFP4 4
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
line 2126
;2126:		}
LABELV $742
line 2128
;2127:
;2128:		switch ( cmd ) {
ADDRLP4 24
CNSTI4 100
ASGNI4
ADDRLP4 0
INDIRI4
ADDRLP4 24
INDIRI4
EQI4 $745
ADDRLP4 0
INDIRI4
CNSTI4 102
EQI4 $746
ADDRLP4 0
INDIRI4
CNSTI4 105
EQI4 $745
ADDRLP4 0
INDIRI4
ADDRLP4 24
INDIRI4
LTI4 $743
LABELV $756
ADDRLP4 0
INDIRI4
CNSTI4 115
EQI4 $747
ADDRLP4 0
INDIRI4
CNSTI4 117
EQI4 $745
ADDRGP4 $743
JUMPV
LABELV $745
line 2132
;2129:		case 'i':
;2130:		case 'd':
;2131:		case 'u':
;2132:			*(va_arg (ap, int *)) = _atoi( &buffer );
ADDRLP4 32
ADDRLP4 8
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 32
INDIRP4
ASGNP4
ADDRFP4 0
ARGP4
ADDRLP4 36
ADDRGP4 _atoi
CALLI4
ASGNI4
ADDRLP4 32
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ADDRLP4 36
INDIRI4
ASGNI4
line 2133
;2133:			break;
ADDRGP4 $744
JUMPV
LABELV $746
line 2135
;2134:		case 'f':
;2135:			*(va_arg (ap, float *)) = _atof( &buffer );
ADDRLP4 40
ADDRLP4 8
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 40
INDIRP4
ASGNP4
ADDRFP4 0
ARGP4
ADDRLP4 44
ADDRGP4 _atof
CALLF4
ASGNF4
ADDRLP4 40
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ADDRLP4 44
INDIRF4
ASGNF4
line 2136
;2136:			break;
ADDRGP4 $744
JUMPV
LABELV $747
line 2138
;2137:		case 's':
;2138:			{
line 2139
;2139:			char *s = va_arg (ap, char *);
ADDRLP4 52
ADDRLP4 8
INDIRP4
CNSTU4 4
ADDP4
ASGNP4
ADDRLP4 8
ADDRLP4 52
INDIRP4
ASGNP4
ADDRLP4 48
ADDRLP4 52
INDIRP4
CNSTI4 -4
ADDP4
INDIRP4
ASGNP4
ADDRGP4 $749
JUMPV
LABELV $748
line 2141
;2140:			while (isspace (*buffer))
;2141:				buffer++;
ADDRFP4 0
ADDRFP4 0
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
LABELV $749
line 2140
ADDRLP4 56
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 56
INDIRI4
CNSTI4 32
EQI4 $748
ADDRLP4 56
INDIRI4
CNSTI4 12
EQI4 $748
ADDRLP4 56
INDIRI4
CNSTI4 10
EQI4 $748
ADDRLP4 56
INDIRI4
CNSTI4 13
EQI4 $748
ADDRLP4 56
INDIRI4
CNSTI4 9
EQI4 $748
ADDRLP4 56
INDIRI4
CNSTI4 11
EQI4 $748
ADDRGP4 $752
JUMPV
LABELV $751
line 2143
;2142:			while (*buffer && !isspace (*buffer) && len-- > 0 )
;2143:				*s++ = *buffer++;
ADDRLP4 60
ADDRLP4 48
INDIRP4
ASGNP4
ADDRLP4 68
CNSTI4 1
ASGNI4
ADDRLP4 48
ADDRLP4 60
INDIRP4
ADDRLP4 68
INDIRI4
ADDP4
ASGNP4
ADDRLP4 64
ADDRFP4 0
INDIRP4
ASGNP4
ADDRFP4 0
ADDRLP4 64
INDIRP4
ADDRLP4 68
INDIRI4
ADDP4
ASGNP4
ADDRLP4 60
INDIRP4
ADDRLP4 64
INDIRP4
INDIRI1
ASGNI1
LABELV $752
line 2142
ADDRLP4 76
ADDRFP4 0
INDIRP4
INDIRI1
CVII4 1
ASGNI4
ADDRLP4 80
CNSTI4 0
ASGNI4
ADDRLP4 76
INDIRI4
ADDRLP4 80
INDIRI4
EQI4 $755
ADDRLP4 76
INDIRI4
CNSTI4 32
EQI4 $755
ADDRLP4 76
INDIRI4
CNSTI4 12
EQI4 $755
ADDRLP4 76
INDIRI4
CNSTI4 10
EQI4 $755
ADDRLP4 76
INDIRI4
CNSTI4 13
EQI4 $755
ADDRLP4 76
INDIRI4
CNSTI4 9
EQI4 $755
ADDRLP4 76
INDIRI4
CNSTI4 11
EQI4 $755
ADDRLP4 72
ADDRLP4 4
INDIRI4
ASGNI4
ADDRLP4 4
ADDRLP4 72
INDIRI4
CNSTI4 1
SUBI4
ASGNI4
ADDRLP4 72
INDIRI4
ADDRLP4 80
INDIRI4
GTI4 $751
LABELV $755
line 2144
;2144:			*s++ = '\0';
ADDRLP4 84
ADDRLP4 48
INDIRP4
ASGNP4
ADDRLP4 48
ADDRLP4 84
INDIRP4
CNSTI4 1
ADDP4
ASGNP4
ADDRLP4 84
INDIRP4
CNSTI1 0
ASGNI1
line 2145
;2145:			break;
LABELV $743
LABELV $744
line 2148
;2146:			}
;2147:		}
;2148:	}
LABELV $737
line 2111
ADDRFP4 4
INDIRP4
INDIRI1
CVII4 1
CNSTI4 0
NEI4 $736
line 2150
;2149:
;2150:	va_end (ap);
ADDRLP4 8
CNSTP4 0
ASGNP4
line 2151
;2151:	return count;
ADDRLP4 12
INDIRI4
RETI4
LABELV $734
endproc sscanf 88 4
import Com_Printf
import Com_Error
import Info_NextPair
import Info_Validate
import Info_SetValueForKey_Big
import Info_SetValueForKey
import Info_RemoveKey_big
import Info_RemoveKey
import Info_ValueForKey
import Com_TruncateLongString
import va
import Q_CountChar
import Q_CleanStr
import Q_PrintStrlen
import Q_strcat
import Q_strncpyz
import Q_stristr
import Q_strupr
import Q_strlwr
import Q_stricmpn
import Q_strncmp
import Q_stricmp
import Q_isalpha
import Q_isupper
import Q_islower
import Q_isprint
import Com_RandomBytes
import Com_SkipCharset
import Com_SkipTokens
import Com_sprintf
import Parse3DMatrix
import Parse2DMatrix
import Parse1DMatrix
import SkipRestOfLine
import SkipBracedSection
import COM_MatchToken
import COM_ParseWarning
import COM_ParseError
import COM_Compress
import COM_ParseExt
import COM_Parse
import COM_GetCurrentParseLine
import COM_BeginParseSession
import COM_DefaultExtension
import COM_StripExtension
import COM_GetExtension
import COM_SkipPath
import Com_Clamp
import Q_isnan
import PerpendicularVector
import AngleVectors
import MatrixMultiply
import MakeNormalVectors
import RotateAroundDirection
import RotatePointAroundVector
import ProjectPointOnPlane
import PlaneFromPoints
import AngleDelta
import AngleNormalize180
import AngleNormalize360
import AnglesSubtract
import AngleSubtract
import LerpAngle
import AngleMod
import BoundsIntersectPoint
import BoundsIntersectSphere
import BoundsIntersect
import BoxOnPlaneSide
import SetPlaneSignbits
import AxisCopy
import AxisClear
import AnglesToAxis
import vectoangles
import Q_crandom
import Q_random
import Q_rand
import Q_acos
import Q_log2
import VectorRotate
import Vector4Scale
import VectorNormalize2
import VectorNormalize
import CrossProduct
import VectorInverse
import VectorNormalizeFast
import DistanceSquared
import Distance
import VectorLengthSquared
import VectorLength
import VectorCompare
import AddPointToBounds
import ClearBounds
import RadiusFromBounds
import NormalizeColor
import ColorBytes4
import ColorBytes3
import _VectorMA
import _VectorScale
import _VectorCopy
import _VectorAdd
import _VectorSubtract
import _DotProduct
import ByteToDir
import DirToByte
import ClampShort
import ClampChar
import Q_rsqrt
import Q_fabs
import axisDefault
import vec3_origin
import g_color_table
import colorDkGrey
import colorMdGrey
import colorLtGrey
import colorWhite
import colorCyan
import colorMagenta
import colorYellow
import colorBlue
import colorGreen
import colorRed
import colorBlack
import bytedirs
import Hunk_Alloc
import FloatSwap
import LongSwap
import ShortSwap
import acos
import atan2
import cos
import sin
import sqrt
import floor
import ceil
import memcpy
import memset
import strncpy
lit
align 1
LABELV $610
byte 1 48
byte 1 49
byte 1 50
byte 1 51
byte 1 52
byte 1 53
byte 1 54
byte 1 55
byte 1 56
byte 1 57
byte 1 97
byte 1 98
byte 1 99
byte 1 100
byte 1 101
byte 1 102
byte 1 0
align 1
LABELV $609
byte 1 48
byte 1 49
byte 1 50
byte 1 51
byte 1 52
byte 1 53
byte 1 54
byte 1 55
byte 1 56
byte 1 57
byte 1 65
byte 1 66
byte 1 67
byte 1 68
byte 1 69
byte 1 70
byte 1 0
align 1
LABELV $575
byte 1 60
byte 1 78
byte 1 85
byte 1 76
byte 1 76
byte 1 62
byte 1 0
align 1
LABELV $279
byte 1 48
byte 1 120
byte 1 0
align 1
LABELV $272
byte 1 105
byte 1 110
byte 1 105
byte 1 116
byte 1 121
byte 1 0
align 1
LABELV $267
byte 1 105
byte 1 110
byte 1 102
byte 1 0
align 1
LABELV $256
byte 1 110
byte 1 97
byte 1 110
byte 1 0
